{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"moment\",\"commonjs2\":\"moment\",\"amd\":\"moment\",\"var\":\"moment\"}","webpack:///./src/birthMonth.enum.js","webpack:///./src/belfiore.js","webpack:///./src/validator.const.js","webpack:///./src/checkDigitizer.js","webpack:///./src/dateValidator.const.js","webpack:///./src/diacritics.js","webpack:///./src/gender.enum.js","webpack:///./src/omocode.enum.js","webpack:///./src/parser.js","webpack:///./src/validator.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","MONTHS","receiver","includes","indexOf","this","data","licenses","activeDate","codeMatcher","province","Error","hiddenValueConf","configurable","writable","defineProperties","_data","_licenses","_activeDate","_codeMatcher","_province","Proxy","constructor","map","resource","Array","from","belfioreCode","length","e","locationByIndex","reduce","a","b","concat","filter","output","g","resourceData","indexer","indexByName","index","roundItem","push","matcher","RegExp","date","code","test","paramName","base32name","belfioreToInt","toString","padStart","binaryfindIndex","text","start","end","currentLength","targetIndex","Math","floor","targetValure","substr","ceil","goAhead","charCodeAt","parseInt","String","fromCharCode","base32daysFrom1861","add","list","startIndex","endIndex","counter","substring","seekEntryEndIndex","entryIndex","targetName","belfioreIndex","belFioreInt","belfioreFromInt","provinceOrCountry","dateIndex","creationDate","decodeDate","startOf","expirationDate","endOf","isBefore","isAfter","nameByIndex","isCountry","dataSource","assign","toDate","iso3166","NAME_MATCHER","FULL_NAME_MATCHER","LEAP_YEAR_MATCHER","DAY_29_MATCHER","DAY_MATCHER","MONTH_DAY_MATCHER","FULL_DATE_MATCHER","MALE_FULL_DATE_MATCHER","FEMALE_FULL_DATE_MATCHER","BELFIORE_CODE_MATCHER","CODICE_FISCALE","PARTIAL_FULL_NAME","PARTIAL_FULL_DATE","PARTIAL_CF","CONSONANT_LIST","VOWEL_LIST","OMOCODE_NUMBER_LIST","OMOCODE_NON_ZERO_NUMBER_LIST","OMOCODE_ZERO_LIST","MONTH_LIST","MONTH_30DAYS_LIST","MONTH_31DAYS_LIST","CITY_CODE_LIST","COUNTRY_CODE_LIST","SURNAME_MATCHER","YEAR_MATCHER","MONTH_MATCHER","DAY_30_MATCHER","DAY_31_MATCHER","MALE_DAY_MATCHER","FEMALE_DAY_MATCHER","CITY_CODE_MATCHER","COUNTRY_CODE_MATCHER","CHECK_DIGIT","PARTIAL_NAME_MATCHER","PARTIAL_YEAR","PARTIAL_MONTH_DAY","PARTIAL_BELFIORE_CODE_MATCHER","CONTROL_CODE_IN","partialCF","split","char","toUpperCase","isNumber","codiceFiscale","partialCfValue","charValue","evaluateChar","YEAR","MONTH","MONTH_DAY","HOURS","TIMEZONE","TIME","ISO8601_SHORT_DATE","ISO8601_DATE_TIME","DAY","LEAP_MONTH","DAYS_30_MONTHS","DAYS_31_MONTHS","MINUTES","SECONDS","MILLISECONDS","DIACRITICS_MAP","A","AA","AE","AO","AU","AV","AY","B","C","D","DZ","Dz","E","F","G","H","I","J","K","L","LJ","Lj","M","N","NJ","Nj","O","OI","OO","OU","P","Q","R","S","T","TZ","U","V","VY","W","X","Y","Z","aa","ae","ao","au","av","ay","dz","f","h","hv","j","k","lj","nj","oi","ou","oo","q","tz","u","v","vy","w","x","y","z","core","freeze","insensitiveMatcher","keys","join","regexp","trim","validator","insensitiveValidator","normalizedLetter","values","find","toArray","apply","isNaN","args","OMOCODE","checkBitmap","offset","OMOCODE_BITMAP","replace","match","surnameCf","cons","vow","matchingLength","cfToSurname","birthDay","birthYear","current2DigitsYear","format","century","subtract","year","birthMonth","cfToBirthDay","cfToBirthMonth","cfToBirthYear","dt","Date","UTC","isValid","birthPlace","birthDate","cfToBirthDate","validityCheck","isSameOrAfter","isSameOrBefore","fiscalCode","month","day","surname","cfToName","gender","cfToGender","place","cfToBirthPlace","noDiacriticsSurname","removeDiacritics","partialCf","consonants","surnameToCf","parsedYear","genderValue","some","param","isArray","parsedDate","parseDate","yearToCf","getFullYear","monthToCf","getMonth","dayGenderToCf","getDate","targetDate","input","active","findByName","results","searchByName","dtParams","yearMonthDayToDate","generator","nameToCf","dateGenderToCf","placeToCf","checkDigit","cf","cfValue","parsedDayM","cfDay","parsedDayGender","parsedDateGender","parsedPlace","parsedCf","encodeCf","cfSurname","cfName","cfDateGender","cfPlace","cfPartValidator","ANY_LETTER","matcherBy","diacriticizer","matchingChars","matchFromCf","charMatcher","diacriticsVowelList","slice","diacriticsConsonantList","dateIso8601","toJSON","diff"],"mappings":"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","file":"codice-fiscale-utils.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"moment\");","const MONTHS = [\r\n    'A',\r\n    'B',\r\n    'C',\r\n    'D',\r\n    'E',\r\n    'H',\r\n    'L',\r\n    'M',\r\n    'P',\r\n    'R',\r\n    'S',\r\n    'T'\r\n];\r\n/**\r\n * @namespace BirthMonth\r\n * @property {number} A 0\r\n * @property {number} B 1\r\n * @property {number} C 2\r\n * @property {number} D 3\r\n * @property {number} E 4\r\n * @property {number} H 5\r\n * @property {number} L 6\r\n * @property {number} M 7\r\n * @property {number} P 8\r\n * @property {number} R 9\r\n * @property {number} S 10\r\n * @property {number} T 11\r\n */\r\nexport default Object.freeze(new Proxy({ MONTHS }, {\r\n    get(receiver, name) {\r\n        if (typeof name  === 'string' && receiver.MONTHS.includes(name)) {\r\n            return receiver.MONTHS.indexOf(name);\r\n        }\r\n        return this[name] || receiver.MONTHS[name] || receiver[name];\r\n    }\r\n}));","import CITIES_COUNTRIES from './asset/cities-countries.json';\r\nimport moment from 'moment';\r\n\r\n/**\r\n * Handler for cities and countries Dataset\r\n * \r\n * @namespace Belfiore\r\n */\r\nclass Belfiore{\r\n    /**\r\n     * \r\n     * @param {Object} param Static json\r\n     * @param {Array<Array<Object>>} param.data Resource data\r\n     * @param {Array<Array<Object>>} param.licenses License array\r\n     * @constructor\r\n     * @private\r\n     */\r\n    constructor({ data, licenses, activeDate, codeMatcher, province }) {\r\n        if (codeMatcher && province) {\r\n            throw new Error('Both codeMatcher and province were provided to Bolfiore, only one is allowed');\r\n        }\r\n        const hiddenValueConf = value => ({\r\n            value,\r\n            enumerable: false,\r\n            configurable: false,\r\n            writable: false\r\n        });\r\n\r\n        Object.defineProperties(this, {\r\n            _data: hiddenValueConf(data),\r\n            _licenses: hiddenValueConf(licenses),\r\n            _activeDate: hiddenValueConf(activeDate),\r\n            _codeMatcher: hiddenValueConf(codeMatcher),\r\n            _province: hiddenValueConf(province)\r\n        });\r\n        return new Proxy(this, this.constructor);\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<Object>} List of places\r\n     * @public\r\n     */\r\n    toArray() {\r\n        return this._data\r\n            .map(resource => Array.from(new Array(resource.belfioreCode.length / 3), (e, i) => this.constructor.locationByIndex(resource, i, {\r\n                activeDate: this._activeDate,\r\n                codeMatcher: this._codeMatcher,\r\n                province: this._province,\r\n                licenses: this._licenses\r\n            })))\r\n            .reduce((a, b) => a.concat(b))\r\n            .filter(e => !!e);\r\n    }\r\n\r\n    /**\r\n     * Search places matching given name\r\n     * @param {string} name Place name\r\n     * @returns {Array<Object>} List of places\r\n     * @public\r\n     */\r\n    searchByName(name) {\r\n        if (!name || typeof name !== 'string') {\r\n            return null;\r\n        }\r\n        let output = [];\r\n        for (let g = 0; g < this._data.length; g++) {\r\n            const resourceData = this._data[g];\r\n            const indexer = this.constructor.indexByName(resourceData.name, name);\r\n            for (let index of indexer) {\r\n                if (index >= 0) {\r\n                    const roundItem = this.constructor.locationByIndex(resourceData, index, {\r\n                        activeDate: this._activeDate,\r\n                        codeMatcher: this._codeMatcher,\r\n                        province: this._province,\r\n                        licenses: this._licenses\r\n                    });\r\n                    if (roundItem) {\r\n                        output.push(roundItem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Find place matching given name, retuns place object if provided name match only 1 result\r\n     * @param {string} name Place name\r\n     * @returns {Object|null}\r\n     * @public\r\n     */\r\n    findByName(name) {\r\n        if (!name || typeof name !== 'string') {\r\n            return null;\r\n        }\r\n        const matcher = new RegExp(`^${name}$`, 'i');\r\n        for (let g = 0; g < this._data.length; g++) {\r\n            const resourceData = this._data[g];\r\n            const indexer = this.constructor.indexByName(resourceData.name, matcher);\r\n            for (let index of indexer) {\r\n                if (index >= 0) {\r\n                    const roundItem = this.constructor.locationByIndex(resourceData, index, {\r\n                        activeDate: this._activeDate,\r\n                        codeMatcher: this._codeMatcher,\r\n                        province: this._province,\r\n                        licenses: this._licenses\r\n                    });\r\n                    if (roundItem) {\r\n                        return roundItem;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns a Proxied version of Belfiore which filters results by given date\r\n     * @param {string|Date|Moment|Array<number>} [date = moment()] Target date to filter places active only for the given date\r\n     * @returns {Belfiore} Belfiore instance filtered by active date\r\n     * @public\r\n     */\r\n    active(date = moment()) {\r\n        const { _data, _licenses, _codeMatcher, _province } = this;\r\n        return new Belfiore({\r\n            data: _data,\r\n            licenses: _licenses,\r\n            activeDate: moment(date),\r\n            province: _province,\r\n            codeMatcher: _codeMatcher\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a Belfiore instance filtered by the given province\r\n     * @param {string} code Province Code (2 A-Z char)\r\n     * @returns {Belfiore} Belfiore instance filtered by province code\r\n     * @public\r\n     */\r\n    byProvince(code) {\r\n        if (!(typeof code === 'string' && (/^[A-Z]{2}$/u).test(code))) {\r\n            return;\r\n        }\r\n        const { _data, _licenses, _activeDate } = this;\r\n        return new Belfiore({\r\n            data: _data,\r\n            licenses: _licenses,\r\n            activeDate: _activeDate,\r\n            province: code\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a Proxied version of Belfiore which filters results by place type\r\n     * @readonly\r\n     * @returns {Belfiore} Belfiore instance filtered by cities\r\n     * @public\r\n     */\r\n    get cities() {\r\n        const { _data, _licenses, _activeDate } = this;\r\n        return new Belfiore({\r\n            data: _data,\r\n            licenses: _licenses,\r\n            activeDate: _activeDate,\r\n            codeMatcher: /^[A-Y]/u\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a Proxied version of Belfiore which filters results by place type\r\n     * @readonly\r\n     * @returns {Belfiore} Belfiore instance filtered by countries\r\n     * @public\r\n     */\r\n    get countries() {\r\n        const { _data, _licenses, _activeDate } = this;\r\n        return new Belfiore({\r\n            data: _data,\r\n            licenses: _licenses,\r\n            activeDate: _activeDate,\r\n            codeMatcher: /^Z/u\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get Proxy\r\n     * @param {Object} resource target resource\r\n     * @param {string|number|Symbol} paramName property name to proxy\r\n     * @returns {*} Proxied property\r\n     * @private\r\n     */\r\n    static get (resource, paramName) {\r\n        if (typeof paramName  === 'string' && (/^[A-Z]\\d{3}$/u).test(paramName)){\r\n            const base32name = this.belfioreToInt(paramName).toString(32).padStart(3, '0');\r\n            for (let g = 0; g < resource._data.length; g++) {\r\n                const resourceData = resource._data[g];\r\n                const index = this.binaryfindIndex(resourceData.belfioreCode, base32name);\r\n                if (index >= 0) {\r\n                    return this.locationByIndex(resourceData, index, {\r\n                        activeDate: resource._activeDate,\r\n                        codeMatcher: resource._codeMatcher,\r\n                        province: resource._province,\r\n                        licenses: resource._licenses\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (\r\n            \r\n            (resource._codeMatcher || resource._province) &&\r\n                ['cities', 'countries'].includes(paramName)\r\n             ||\r\n            \r\n                paramName === 'byProvince' &&\r\n                (resource._codeMatcher.test('Z000') || resource._province)\r\n            \r\n        ) {\r\n            return;\r\n        }\r\n\r\n        return resource[paramName];\r\n    }\r\n\r\n    /**\r\n     * Binary find Index (works ONLY in sorted arrays)\r\n     * @param {string} text Unique string of values of the same length (step)\r\n     * @param {string} value Exact text to find\r\n     * @param {number} start text start index for seeking the value\r\n     * @param {number} end text end index for seeking the value\r\n     * @param {number} step length of a single value to seek properly the text string\r\n     * @returns {number} Found value Index or -1 if not found\r\n     * @private\r\n     */\r\n    static binaryfindIndex(text, value, start, end) {\r\n        if (typeof text !== 'string' || !text.length) {\r\n            return -1;\r\n        }\r\n        if (!start || start < 0) {\r\n            start = 0;\r\n        }\r\n        if (!end || end >= text.length) {\r\n            end = text.length -1;\r\n        }\r\n        const currentLength = end - start + 1;\r\n        if (start > end || currentLength % value.length) {\r\n            return -1;\r\n        }\r\n        const targetIndex = start + Math.floor(currentLength/(2*value.length))*value.length;\r\n        const targetValure = text.substr(targetIndex, value.length);\r\n        if (targetValure === value) {\r\n            return Math.ceil((targetIndex + 1) / value.length) -1;\r\n        }\r\n        const goAhead = value > targetValure;\r\n        return this.binaryfindIndex(text, value, goAhead ? targetIndex + value.length : start, goAhead ? end : targetIndex - 1);\r\n    }\r\n\r\n    /**\r\n     * Converts belfiore code into an int\r\n     * @param {string} code Belfiore Code\r\n     * @returns {number} Int version of belfiore code\r\n     * @private\r\n     */\r\n    static belfioreToInt(code) {\r\n        return (code.charCodeAt()-65)*10**3 + parseInt(code.substr(1));\r\n    }\r\n\r\n    /**\r\n     * Converts int to belfiore code\r\n     * @param {number} code Belfiore int code\r\n     * @returns {string} Standard belfiore code\r\n     * @private\r\n     */\r\n    static belfioreFromInt(code) {\r\n        return `${String.fromCharCode(Math.floor(code / 10**3) + 65)}${code.toString().substr(-3).padStart(3, '0')}`;\r\n    }\r\n\r\n    /**\r\n     * Converst Base 32 number of days since 01/01/1861 to Moment instance\r\n     * @param {string} base32daysFrom1861 Base 32 number of days from 1861-01-01\r\n     * @returns {Moment} Moment instance date\r\n     * @private\r\n     */\r\n    static decodeDate(base32daysFrom1861) {\r\n        return moment('1861-01-01').add(parseInt(base32daysFrom1861, 32) ,'days');\r\n    }\r\n\r\n    /**\r\n     * Retrieve string at index posizion\r\n     * @param {string} [list=''] concatenation of names\r\n     * @param {number} index target name index\r\n     * @returns {string} index-th string\r\n     * @private\r\n     */\r\n    static nameByIndex(list = '', index) {\r\n        let startIndex = 0,\r\n            endIndex = list.indexOf('|', startIndex + 1),\r\n            counter = index;\r\n\r\n        while (counter > 0 && endIndex > startIndex) {\r\n            counter--;\r\n            startIndex = endIndex + 1;\r\n            endIndex = list.indexOf('|', startIndex + 1);\r\n        }\r\n        \r\n        if (index < 0 || counter > 0) {\r\n            throw new Error(`[Belfiore.nameByIndex] Provided index ${index} is out range`);\r\n        }\r\n\r\n        if (!counter && endIndex < 0) {\r\n            return list.substring(startIndex);\r\n        }\r\n\r\n        return list.substring(startIndex, endIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieve string at index posizion\r\n     * @generator\r\n     * @param {string} [list=''] concatenation of names\r\n     * @param {string|RegExp} matcher target name index\r\n     * @yields {number} index\r\n     * @returns {number} -1 when Done\r\n     * @private\r\n     */\r\n    static* indexByName(list = '', matcher) {\r\n        if (typeof matcher === 'string') {\r\n            matcher = new RegExp(matcher, 'i');\r\n        }\r\n        const seekEntryEndIndex = index => list.indexOf('|', index +1) + 1 || list.length;\r\n        \r\n        for(let startIndex = 0, entryIndex = 0; startIndex < list.length; entryIndex++) {\r\n            const endIndex = seekEntryEndIndex(startIndex);\r\n            const targetName = list.substring(startIndex, endIndex -1);\r\n            if (matcher.test(targetName)) {\r\n                yield entryIndex;\r\n            }\r\n            // Moving to next entry to chgeck\r\n            startIndex = endIndex;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Retrieve location for the given index in the given subset\r\n     * @param {string} resourceData concatenation of names\r\n     * @param {number} index target name index\r\n     * @returns {Object} location\r\n     * @private\r\n     */\r\n    static locationByIndex(resourceData, index, { activeDate, codeMatcher, province, licenses } = {}) {\r\n        const belfioreIndex = index * 3;\r\n        if (resourceData.belfioreCode.length - belfioreIndex < 3) {\r\n            return null;\r\n        }\r\n        const belFioreInt = parseInt(resourceData.belfioreCode.substr(belfioreIndex, 3), '32');\r\n        const belfioreCode = this.belfioreFromInt(belFioreInt);\r\n        if (codeMatcher && !codeMatcher.test(belfioreCode)) {\r\n            return null;\r\n        }\r\n        const code = resourceData.provinceOrCountry.substr(index * 2, 2);\r\n        if (province && province !== code) {\r\n            return null;\r\n        }\r\n\r\n        const dateIndex = index * 4;\r\n        const creationDate = this.decodeDate((resourceData.creationDate || '').substr(dateIndex, 4) || '0').startOf('day');\r\n        const expirationDate = this.decodeDate((resourceData.expirationDate || '').substr(dateIndex, 4) || '2qn13').endOf('day');\r\n        if (\r\n            activeDate && \r\n            (\r\n                resourceData.creationDate && activeDate.isBefore(creationDate, 'day') ||\r\n                resourceData.expirationDate &&  activeDate.isAfter(expirationDate, 'day')\r\n            )\r\n        ) {\r\n            return null;\r\n        }\r\n        const name = this.nameByIndex(resourceData.name, index);\r\n        const isCountry = belfioreCode[0] === 'Z';\r\n\r\n        const dataSource = licenses[parseInt(parseInt(resourceData.dataSource, 32).toString(2).padStart(resourceData.belfioreCode.length * 2/3, 0).substr(index * 2, 2), 2)];\r\n\r\n        return Object.assign({\r\n            belfioreCode,\r\n            name,\r\n            creationDate: creationDate.toDate(),\r\n            expirationDate: expirationDate.toDate(),\r\n            dataSource\r\n        }, isCountry ? {\r\n            iso3166: code\r\n        } : {\r\n            province: code\r\n        });\r\n    }\r\n}\r\n\r\nexport default new Belfiore(CITIES_COUNTRIES);","const CONSONANT_LIST = 'B-DF-HJ-NP-TV-Z';\r\nconst VOWEL_LIST = 'AEIOU';\r\nconst OMOCODE_NUMBER_LIST = '\\\\dLMNP-V';\r\nconst OMOCODE_NON_ZERO_NUMBER_LIST = '1-9MNP-V';\r\nconst OMOCODE_ZERO_LIST = '0L';\r\nconst MONTH_LIST = 'A-EHLMPR-T';\r\nconst MONTH_30DAYS_LIST = 'DHPS';\r\nconst MONTH_31DAYS_LIST = 'ACELMRT';\r\nconst CITY_CODE_LIST = 'A-M';\r\nconst COUNTRY_CODE_LIST = 'Z';\r\n\r\nconst NAME_MATCHER = `[A-Z][${VOWEL_LIST}][${VOWEL_LIST}X]|[${CONSONANT_LIST}]{2}[A-Z]`;\r\nconst SURNAME_MATCHER = NAME_MATCHER;\r\nconst FULL_NAME_MATCHER = `(?:${NAME_MATCHER}){2}`;\r\n\r\nconst YEAR_MATCHER = `[${OMOCODE_NUMBER_LIST}]{2}`;\r\nconst LEAP_YEAR_MATCHER = '[02468LNQSU][048LQU]|[13579MPRTV][26NS]';\r\nconst MONTH_MATCHER = `[${MONTH_LIST}]`;\r\nconst DAY_2X_MATCHER = '[26NS]';\r\nconst DAY_3X_MATCHER = '[37PT]';\r\nconst DAY_29_MATCHER = `[${OMOCODE_ZERO_LIST}4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[1256MNRS][${OMOCODE_NUMBER_LIST}]`;\r\nconst DAY_30_MATCHER = `[${DAY_3X_MATCHER}][${OMOCODE_ZERO_LIST}]`;\r\nconst DAY_31_MATCHER = `[${DAY_3X_MATCHER}][${OMOCODE_ZERO_LIST}1M]`;\r\n\r\nconst DAY_MATCHER = `(?:${DAY_29_MATCHER}|${DAY_3X_MATCHER}[${OMOCODE_ZERO_LIST}1M])`;\r\nconst MALE_DAY_MATCHER = `(?:[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[12MN][${OMOCODE_NUMBER_LIST}]|[3P][${OMOCODE_ZERO_LIST}1M])`;\r\nconst FEMALE_DAY_MATCHER = `(?:[4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[56RS][${OMOCODE_NUMBER_LIST}]|[7T][${OMOCODE_ZERO_LIST}1M])`;\r\nconst MONTH_DAY_MATCHER = `${MONTH_MATCHER}(?:${DAY_29_MATCHER})|[${MONTH_30DAYS_LIST}]${DAY_30_MATCHER}|[${MONTH_31DAYS_LIST}]${DAY_31_MATCHER}`;\r\nconst FULL_DATE_MATCHER = `${YEAR_MATCHER}(?:${MONTH_MATCHER}(?:[${OMOCODE_ZERO_LIST}4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[15MR][${OMOCODE_NUMBER_LIST}]|${DAY_2X_MATCHER}[0-8LMNP-U])|[${MONTH_30DAYS_LIST}]${DAY_3X_MATCHER}[${OMOCODE_ZERO_LIST}]|[${MONTH_31DAYS_LIST}]${DAY_3X_MATCHER}[${OMOCODE_ZERO_LIST}1M]|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}]${DAY_2X_MATCHER}[9V])|(?:${LEAP_YEAR_MATCHER})B${DAY_2X_MATCHER}[9V]`;\r\nconst MALE_FULL_DATE_MATCHER = `${YEAR_MATCHER}(?:${MONTH_MATCHER}(?:[${OMOCODE_ZERO_LIST}4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[1M][${OMOCODE_NUMBER_LIST}]|[2N][0-8LMNP-U])|[${MONTH_30DAYS_LIST}][3P][${OMOCODE_ZERO_LIST}]|[${MONTH_31DAYS_LIST}][3P][${OMOCODE_ZERO_LIST}1M]|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}][2N][9V])|(?:${LEAP_YEAR_MATCHER})B[2N][9V]`;\r\nconst FEMALE_FULL_DATE_MATCHER = `${YEAR_MATCHER}(?:${MONTH_MATCHER}(?:[${OMOCODE_ZERO_LIST}4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[5R][${OMOCODE_NUMBER_LIST}]|[6S][0-8LMNP-U])|[${MONTH_30DAYS_LIST}][7T][${OMOCODE_ZERO_LIST}]|[${MONTH_31DAYS_LIST}][7T][${OMOCODE_ZERO_LIST}1M]|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}][6S][9V])|(?:${LEAP_YEAR_MATCHER})B[6S][9V]`;\r\n\r\nconst CITY_CODE_MATCHER = `[${CITY_CODE_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]{2}|[${OMOCODE_ZERO_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]|[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]))`;\r\nconst COUNTRY_CODE_MATCHER = `${COUNTRY_CODE_LIST}[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]{2}`;\r\nconst BELFIORE_CODE_MATCHER = `(?:[${CITY_CODE_LIST}${COUNTRY_CODE_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]{2})|(?:[${CITY_CODE_LIST}][${OMOCODE_ZERO_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]|[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]))`;\r\n\r\nconst CHECK_DIGIT = '[A-Z]';\r\n\r\nconst CODICE_FISCALE = `${FULL_NAME_MATCHER}(?:${FULL_DATE_MATCHER})(?:${BELFIORE_CODE_MATCHER})${CHECK_DIGIT}`;\r\n\r\n\r\nconst PARTIAL_NAME_MATCHER = `[A-Z][${VOWEL_LIST}]?|[${CONSONANT_LIST}]{1,2}`;\r\nconst PARTIAL_FULL_NAME = `(?:${PARTIAL_NAME_MATCHER})|(?:(?:${NAME_MATCHER})(?:${PARTIAL_NAME_MATCHER})?)`;\r\nconst PARTIAL_YEAR = `[${OMOCODE_NUMBER_LIST}]`;\r\nconst PARTIAL_MONTH_DAY = `${MONTH_MATCHER}[${OMOCODE_ZERO_LIST}12456MNQRS]?|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}]${DAY_3X_MATCHER}`;\r\nconst PARTIAL_FULL_DATE =`${PARTIAL_YEAR}|(?:${YEAR_MATCHER}(?:${PARTIAL_MONTH_DAY})?)`;\r\nconst PARTIAL_BELFIORE_CODE_MATCHER = `[${CITY_CODE_LIST}${COUNTRY_CODE_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]?)?|[${COUNTRY_CODE_LIST}](?:[${OMOCODE_ZERO_LIST}][${OMOCODE_NUMBER_LIST}]?)?`;\r\n\r\nconst PARTIAL_CF = `${PARTIAL_FULL_NAME}|(?:${FULL_NAME_MATCHER}(?:(?:${PARTIAL_FULL_DATE})|(?:${FULL_DATE_MATCHER})(?:(?:${PARTIAL_BELFIORE_CODE_MATCHER})|(?:${BELFIORE_CODE_MATCHER})${CHECK_DIGIT}?)?)?)?`;\r\n\r\n/**\r\n * Validator constants\r\n * @readonly\r\n * @returns {Object} VALIDATOR\r\n * \r\n * @constant {string} VALIDATOR.CONSONANT_LIST List of consonant to be used in a RegExp\r\n * @constant {string} VALIDATOR.VOWEL_LIST List of vowels to be used in a RegExp\r\n * @constant {string} VALIDATOR.OMOCODE_NUMBER_LIST List of numbers and their omocode counterparts to be used in a RegExp\r\n * @constant {string} VALIDATOR.OMOCODE_NON_ZERO_NUMBER_LIST List of numbers but 0 and their omocode counterparts to be used in a RegExp\r\n * @constant {string} VALIDATOR.OMOCODE_ZERO_LIST List of 0 and its omocode counterpart to be used in a RegExp\r\n * @constant {string} VALIDATOR.MONTH_LIST\r\n * @constant {string} VALIDATOR.MONTH_30DAYS_LIST\r\n * @constant {string} VALIDATOR.MONTH_31DAYS_LIST\r\n * @constant {string} VALIDATOR.CITY_CODE_LIST\r\n * @constant {string} VALIDATOR.COUNTRY_CODE_LIST\r\n * @constant {string} VALIDATOR.NAME_MATCHER\r\n * @constant {string} VALIDATOR.SURNAME_MATCHER\r\n * @constant {string} VALIDATOR.FULL_NAME_MATCHER\r\n * @constant {string} VALIDATOR.YEAR_MATCHER\r\n * @constant {string} VALIDATOR.LEAP_YEAR_MATCHER\r\n * @constant {string} VALIDATOR.MONTH_MATCHER\r\n * @constant {string} VALIDATOR.DAY_29_MATCHER\r\n * @constant {string} VALIDATOR.DAY_30_MATCHER\r\n * @constant {string} VALIDATOR.DAY_31_MATCHER\r\n * @constant {string} VALIDATOR.DAY_MATCHER\r\n * @constant {string} VALIDATOR.MALE_DAY_MATCHER\r\n * @constant {string} VALIDATOR.FEMALE_DAY_MATCHER\r\n * @constant {string} VALIDATOR.MONTH_DAY_MATCHER\r\n * @constant {string} VALIDATOR.FULL_DATE_MATCHER\r\n * @constant {string} VALIDATOR.MALE_FULL_DATE_MATCHER\r\n * @constant {string} VALIDATOR.FEMALE_FULL_DATE_MATCHER\r\n * @constant {string} VALIDATOR.CITY_CODE_MATCHER\r\n * @constant {string} VALIDATOR.COUNTRY_CODE_MATCHER\r\n * @constant {string} VALIDATOR.BELFIORE_CODE_MATCHER\r\n * @constant {string} VALIDATOR.CHECK_DIGIT\r\n * @constant {string} VALIDATOR.CODICE_FISCALE\r\n * @constant {string} VALIDATOR.PARTIAL_NAME_MATCHER\r\n * @constant {string} VALIDATOR.PARTIAL_FULL_NAME\r\n * @constant {string} VALIDATOR.PARTIAL_YEAR\r\n * @constant {string} VALIDATOR.PARTIAL_MONTH_DAY\r\n * @constant {string} VALIDATOR.PARTIAL_FULL_DATE\r\n * @constant {string} VALIDATOR.PARTIAL_BELFIORE_CODE_MATCHER\r\n * @constant {string} VALIDATOR.PARTIAL_CF\r\n * \r\n * @namespace VALIDATOR\r\n */\r\nexport default Object.freeze({\r\n    CONSONANT_LIST,\r\n    VOWEL_LIST,\r\n    OMOCODE_NUMBER_LIST,\r\n    OMOCODE_NON_ZERO_NUMBER_LIST,\r\n    OMOCODE_ZERO_LIST,\r\n    MONTH_LIST,\r\n    MONTH_30DAYS_LIST,\r\n    MONTH_31DAYS_LIST,\r\n    CITY_CODE_LIST,\r\n    COUNTRY_CODE_LIST,\r\n    NAME_MATCHER,\r\n    SURNAME_MATCHER,\r\n    FULL_NAME_MATCHER,\r\n    YEAR_MATCHER,\r\n    LEAP_YEAR_MATCHER,\r\n    MONTH_MATCHER,\r\n    DAY_29_MATCHER,\r\n    DAY_30_MATCHER,\r\n    DAY_31_MATCHER,\r\n    DAY_MATCHER,\r\n    MALE_DAY_MATCHER,\r\n    FEMALE_DAY_MATCHER,\r\n    MONTH_DAY_MATCHER,\r\n    FULL_DATE_MATCHER,\r\n    MALE_FULL_DATE_MATCHER,\r\n    FEMALE_FULL_DATE_MATCHER,\r\n    CITY_CODE_MATCHER,\r\n    COUNTRY_CODE_MATCHER,\r\n    BELFIORE_CODE_MATCHER,\r\n    CHECK_DIGIT,\r\n    CODICE_FISCALE,\r\n    PARTIAL_NAME_MATCHER,\r\n    PARTIAL_FULL_NAME,\r\n    PARTIAL_YEAR,\r\n    PARTIAL_MONTH_DAY,\r\n    PARTIAL_FULL_DATE,\r\n    PARTIAL_BELFIORE_CODE_MATCHER,\r\n    PARTIAL_CF\r\n});","import VALIDATOR from './validator.const';\r\n\r\nconst CONTROL_CODE_IN = {\r\n    'A': 1,\r\n    'B': 0,\r\n    'C': 5,\r\n    'D': 7,\r\n    'E': 9,\r\n    'F': 13,\r\n    'G': 15,\r\n    'H': 17,\r\n    'I': 19,\r\n    'J': 21,\r\n    'K': 2,\r\n    'L': 4,\r\n    'M': 18,\r\n    'N': 20,\r\n    'O': 11,\r\n    'P': 3,\r\n    'Q': 6,\r\n    'R': 8,\r\n    'S': 12,\r\n    'T': 14,\r\n    'U': 16,\r\n    'V': 10,\r\n    'W': 22,\r\n    'X': 25,\r\n    'Y': 24,\r\n    'Z': 23\r\n};\r\n\r\n\r\n/**\r\n * CodiceFiscal 16th char check digit calculator\r\n * @class\r\n * @public\r\n *//**\r\n *\r\n * @namespace CheckDigitizer\r\n */\r\nclass CheckDigitizer {\r\n\r\n    /**\r\n     * Partial FiscalCode Evaluator\r\n     * @param {string} [partialCF=''] Partial Fiscal Code to evaluate\r\n     * @generator\r\n     * @yields {number} character value odd/even\r\n     * @returns {number} 0\r\n     * @public\r\n     */\r\n    static* evaluateChar(partialCF = '') {\r\n        for(let index in partialCF.split('')){\r\n            const char = partialCF[index].toUpperCase();\r\n            const isNumber = (/^\\d/u).test(char);\r\n            //Odd/Even are shifted/swapped (array starts from 0, 'Agenzia delle Entrate' documentation counts the string from 1)\r\n            if (index%2) {\r\n                //Odd positions\r\n                yield char.charCodeAt(0) - (isNumber ? 48 : 65);\r\n            } else {\r\n                //Even positions\r\n                yield CONTROL_CODE_IN[isNumber ? String.fromCharCode(parseInt(char) + 65) : char];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Evaluate given partial CF to produce last check digit character\r\n     * @param {string} codiceFiscale Partial or complete Fiscal Code to evaluate to produce last character\r\n     * @returns {char|null} 16th CF char\r\n     * @public\r\n     */\r\n    static checkDigit(codiceFiscale) {\r\n        if (typeof codiceFiscale === 'string' && (new RegExp(VALIDATOR.PARTIAL_CF)).test(codiceFiscale)) {\r\n            const partialCF = codiceFiscale.substr(0, 15);\r\n            let partialCfValue = 0;\r\n            for (let charValue of this.evaluateChar(partialCF)) partialCfValue += charValue;\r\n            return String.fromCharCode(partialCfValue%26 + 65);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport default CheckDigitizer;","const YEAR = '[12][0-9]{3}';\r\nconst MONTH = '0[1-9]|1[0-2]';\r\nconst DAY = '0[1-9]|[12][0-9]|3[01]';\r\nconst LEAP_MONTH = '02';\r\nconst DAYS_30_MONTHS = '0[469]|11';\r\nconst DAYS_31_MONTHS = '0[13578]|1[02]';\r\nconst MONTH_DAY = `(?:${MONTH})-(?:0[1-9]|[12]\\\\d)|(?:${DAYS_30_MONTHS})-30|(?:${DAYS_31_MONTHS})-3[01]`;\r\nconst HOURS = '[01]\\\\d|2[0-3]';\r\nconst MINUTES = '[0-5]\\\\d';\r\nconst SECONDS = MINUTES;\r\nconst MILLISECONDS = '\\\\d{3}';\r\nconst TIMEZONE = `Z|[-+](?:${HOURS})(?::?${MINUTES})?`;\r\nconst TIME = `(?:${HOURS})(?::${MINUTES}(?::${SECONDS}(\\\\.${MILLISECONDS})?)?(?:${TIMEZONE})?)?`;\r\nconst ISO8601_SHORT_DATE = `${YEAR}-(?:${MONTH_DAY})(?:T${TIME})?`;\r\nconst ISO8601_DATE_TIME = `${YEAR}(?:-(?:(?:${MONTH})|(?:${MONTH_DAY})(?:T${TIME})?))?`;\r\n\r\n/**\r\n * Date Validator propertys\r\n * @namespace DATE_VALIDATOR\r\n * @property {Object} DATE_VALIDATOR\r\n * @property {string} DATE_VALIDATOR.YEAR String matcher for ISO8601 4 digits year (limited to 1000-2999)\r\n * @property {string} DATE_VALIDATOR.MONTH String matcher for ISO8601 2 digits month (01-12)\r\n * @property {string} DATE_VALIDATOR.DAY String matcher for ISO8601 2 digits day (01-31)\r\n * @property {string} DATE_VALIDATOR.LEAP_MONTH String matcher for ISO8601 2 digits leap month\r\n * @property {string} DATE_VALIDATOR.DAYS_30_MONTHS String matcher for ISO8601 2 digits 30 days month\r\n * @property {string} DATE_VALIDATOR.DAYS_31_MONTHS String matcher for ISO8601 2 digits 31 days month\r\n * @property {string} DATE_VALIDATOR.MONTH_DAY String matcher for ISO8601 2 digits month + 2 digit day tailored for 28/29, 30 and 31 days months (##-##)\r\n * @property {string} DATE_VALIDATOR.ISO8601_SHORT_DATE String matcher for ISO8601 date: 4 digits year, 2 digits month and 2 digit day tailored for 28/29, 30 and 31 days months (####-##-##)\r\n * @property {string} DATE_VALIDATOR.HOURS String matcher for ISO8601 2 digits hours (00-23)\r\n * @property {string} DATE_VALIDATOR.MINUTES String matcher for ISO8601 2 digits minutes (00-59)\r\n * @property {string} DATE_VALIDATOR.SECONDS String matcher for ISO8601 2 digits seconds (00-59)\r\n * @property {string} DATE_VALIDATOR.MILLISECONDS String matcher for ISO8601 3 digits milliseconds (000-999)\r\n * @property {string} DATE_VALIDATOR.TIMEZONE String matcher for ISO8601 timezone (Z or ±## or ±##:## or ±####)\r\n * @property {string} DATE_VALIDATOR.TIME String matcher for ISO8601 for time (T## , T##:## , T##:##:## , T##:##:##.###)\r\n * @property {string} DATE_VALIDATOR.ISO8601_DATE_TIME String matcher for ISO8601 date/time format\r\n*/\r\nexport default Object.freeze({\r\n    YEAR,\r\n    MONTH,\r\n    DAY,\r\n    LEAP_MONTH,\r\n    DAYS_30_MONTHS,\r\n    DAYS_31_MONTHS,\r\n    MONTH_DAY,\r\n    ISO8601_SHORT_DATE,\r\n    HOURS,\r\n    MINUTES,\r\n    SECONDS,\r\n    MILLISECONDS,\r\n    TIMEZONE,\r\n    TIME,\r\n    ISO8601_DATE_TIME\r\n});","const DIACRITICS_MAP = {\r\n    A: '\\u0041\\u24B6\\uFF21\\u00C0\\u00C1\\u00C2\\u1EA6\\u1EA4\\u1EAA\\u1EA8\\u00C3\\u0100\\u0102\\u1EB0\\u1EAE\\u1EB4\\u1EB2\\u0226\\u01E0\\u00C4\\u01DE\\u1EA2\\u00C5\\u01FA\\u01CD\\u0200\\u0202\\u1EA0\\u1EAC\\u1EB6\\u1E00\\u0104\\u023A\\u2C6F',\r\n    AA: '\\uA732',\r\n    AE: '\\u00C6\\u01FC\\u01E2',\r\n    AO: '\\uA734',\r\n    AU: '\\uA736',\r\n    AV: '\\uA738\\uA73A',\r\n    AY: '\\uA73C',\r\n    B: '\\u0042\\u24B7\\uFF22\\u1E02\\u1E04\\u1E06\\u0243\\u0182\\u0181',\r\n    C: '\\u0043\\u24B8\\uFF23\\u0106\\u0108\\u010A\\u010C\\u00C7\\u1E08\\u0187\\u023B\\uA73E',\r\n    D: '\\u0044\\u24B9\\uFF24\\u1E0A\\u010E\\u1E0C\\u1E10\\u1E12\\u1E0E\\u0110\\u018B\\u018A\\u0189\\uA779',\r\n    DZ: '\\u01F1\\u01C4',\r\n    Dz: '\\u01F2\\u01C5',\r\n    E: '\\u0045\\u24BA\\uFF25\\u00C8\\u00C9\\u00CA\\u1EC0\\u1EBE\\u1EC4\\u1EC2\\u1EBC\\u0112\\u1E14\\u1E16\\u0114\\u0116\\u00CB\\u1EBA\\u011A\\u0204\\u0206\\u1EB8\\u1EC6\\u0228\\u1E1C\\u0118\\u1E18\\u1E1A\\u0190\\u018E',\r\n    F: '\\u0046\\u24BB\\uFF26\\u1E1E\\u0191\\uA77B',\r\n    G: '\\u0047\\u24BC\\uFF27\\u01F4\\u011C\\u1E20\\u011E\\u0120\\u01E6\\u0122\\u01E4\\u0193\\uA7A0\\uA77D\\uA77E',\r\n    H: '\\u0048\\u24BD\\uFF28\\u0124\\u1E22\\u1E26\\u021E\\u1E24\\u1E28\\u1E2A\\u0126\\u2C67\\u2C75\\uA78D',\r\n    I: '\\u0049\\u24BE\\uFF29\\u00CC\\u00CD\\u00CE\\u0128\\u012A\\u012C\\u0130\\u00CF\\u1E2E\\u1EC8\\u01CF\\u0208\\u020A\\u1ECA\\u012E\\u1E2C\\u0197',\r\n    J: '\\u004A\\u24BF\\uFF2A\\u0134\\u0248',\r\n    K: '\\u004B\\u24C0\\uFF2B\\u1E30\\u01E8\\u1E32\\u0136\\u1E34\\u0198\\u2C69\\uA740\\uA742\\uA744\\uA7A2',\r\n    L: '\\u004C\\u24C1\\uFF2C\\u013F\\u0139\\u013D\\u1E36\\u1E38\\u013B\\u1E3C\\u1E3A\\u0141\\u023D\\u2C62\\u2C60\\uA748\\uA746\\uA780',\r\n    LJ: '\\u01C7',\r\n    Lj: '\\u01C8',\r\n    M: '\\u004D\\u24C2\\uFF2D\\u1E3E\\u1E40\\u1E42\\u2C6E\\u019C',\r\n    N: '\\u004E\\u24C3\\uFF2E\\u01F8\\u0143\\u00D1\\u1E44\\u0147\\u1E46\\u0145\\u1E4A\\u1E48\\u0220\\u019D\\uA790\\uA7A4',\r\n    NJ: '\\u01CA',\r\n    Nj: '\\u01CB',\r\n    O: '\\u004F\\u24C4\\uFF2F\\u00D2\\u00D3\\u00D4\\u1ED2\\u1ED0\\u1ED6\\u1ED4\\u00D5\\u1E4C\\u022C\\u1E4E\\u014C\\u1E50\\u1E52\\u014E\\u022E\\u0230\\u00D6\\u022A\\u1ECE\\u0150\\u01D1\\u020C\\u020E\\u01A0\\u1EDC\\u1EDA\\u1EE0\\u1EDE\\u1EE2\\u1ECC\\u1ED8\\u01EA\\u01EC\\u00D8\\u01FE\\u0186\\u019F\\uA74A\\uA74C',\r\n    OI: '\\u01A2',\r\n    OO: '\\uA74E',\r\n    OU: '\\u0222',\r\n    P: '\\u0050\\u24C5\\uFF30\\u1E54\\u1E56\\u01A4\\u2C63\\uA750\\uA752\\uA754',\r\n    Q: '\\u0051\\u24C6\\uFF31\\uA756\\uA758\\u024A',\r\n    R: '\\u0052\\u24C7\\uFF32\\u0154\\u1E58\\u0158\\u0210\\u0212\\u1E5A\\u1E5C\\u0156\\u1E5E\\u024C\\u2C64\\uA75A\\uA7A6\\uA782',\r\n    S: '\\u0053\\u24C8\\uFF33\\u1E9E\\u015A\\u1E64\\u015C\\u1E60\\u0160\\u1E66\\u1E62\\u1E68\\u0218\\u015E\\u2C7E\\uA7A8\\uA784',\r\n    T: '\\u0054\\u24C9\\uFF34\\u1E6A\\u0164\\u1E6C\\u021A\\u0162\\u1E70\\u1E6E\\u0166\\u01AC\\u01AE\\u023E\\uA786',\r\n    TZ: '\\uA728',\r\n    U: '\\u0055\\u24CA\\uFF35\\u00D9\\u00DA\\u00DB\\u0168\\u1E78\\u016A\\u1E7A\\u016C\\u00DC\\u01DB\\u01D7\\u01D5\\u01D9\\u1EE6\\u016E\\u0170\\u01D3\\u0214\\u0216\\u01AF\\u1EEA\\u1EE8\\u1EEE\\u1EEC\\u1EF0\\u1EE4\\u1E72\\u0172\\u1E76\\u1E74\\u0244',\r\n    V: '\\u0056\\u24CB\\uFF36\\u1E7C\\u1E7E\\u01B2\\uA75E\\u0245',\r\n    VY: '\\uA760',\r\n    W: '\\u0057\\u24CC\\uFF37\\u1E80\\u1E82\\u0174\\u1E86\\u1E84\\u1E88\\u2C72',\r\n    X: '\\u0058\\u24CD\\uFF38\\u1E8A\\u1E8C',\r\n    Y: '\\u0059\\u24CE\\uFF39\\u1EF2\\u00DD\\u0176\\u1EF8\\u0232\\u1E8E\\u0178\\u1EF6\\u1EF4\\u01B3\\u024E\\u1EFE',\r\n    Z: '\\u005A\\u24CF\\uFF3A\\u0179\\u1E90\\u017B\\u017D\\u1E92\\u1E94\\u01B5\\u0224\\u2C7F\\u2C6B\\uA762',\r\n    a: '\\u0061\\u24D0\\uFF41\\u1E9A\\u00E0\\u00E1\\u00E2\\u1EA7\\u1EA5\\u1EAB\\u1EA9\\u00E3\\u0101\\u0103\\u1EB1\\u1EAF\\u1EB5\\u1EB3\\u0227\\u01E1\\u00E4\\u01DF\\u1EA3\\u00E5\\u01FB\\u01CE\\u0201\\u0203\\u1EA1\\u1EAD\\u1EB7\\u1E01\\u0105\\u2C65\\u0250',\r\n    aa: '\\uA733',\r\n    ae: '\\u00E6\\u01FD\\u01E3',\r\n    ao: '\\uA735',\r\n    au: '\\uA737',\r\n    av: '\\uA739\\uA73B',\r\n    ay: '\\uA73D',\r\n    b: '\\u0062\\u24D1\\uFF42\\u1E03\\u1E05\\u1E07\\u0180\\u0183\\u0253',\r\n    c: '\\u0063\\u24D2\\uFF43\\u0107\\u0109\\u010B\\u010D\\u00E7\\u1E09\\u0188\\u023C\\uA73F\\u2184',\r\n    d: '\\u0064\\u24D3\\uFF44\\u1E0B\\u010F\\u1E0D\\u1E11\\u1E13\\u1E0F\\u0111\\u018C\\u0256\\u0257\\uA77A',\r\n    dz: '\\u01F3\\u01C6',\r\n    e: '\\u0065\\u24D4\\uFF45\\u00E8\\u00E9\\u00EA\\u1EC1\\u1EBF\\u1EC5\\u1EC3\\u1EBD\\u0113\\u1E15\\u1E17\\u0115\\u0117\\u00EB\\u1EBB\\u011B\\u0205\\u0207\\u1EB9\\u1EC7\\u0229\\u1E1D\\u0119\\u1E19\\u1E1B\\u0247\\u025B\\u01DD',\r\n    f: '\\u0066\\u24D5\\uFF46\\u1E1F\\u0192\\uA77C',\r\n    g: '\\u0067\\u24D6\\uFF47\\u01F5\\u011D\\u1E21\\u011F\\u0121\\u01E7\\u0123\\u01E5\\u0260\\uA7A1\\u1D79\\uA77F',\r\n    h: '\\u0068\\u24D7\\uFF48\\u0125\\u1E23\\u1E27\\u021F\\u1E25\\u1E29\\u1E2B\\u1E96\\u0127\\u2C68\\u2C76\\u0265',\r\n    hv: '\\u0195',\r\n    i: '\\u0069\\u24D8\\uFF49\\u00EC\\u00ED\\u00EE\\u0129\\u012B\\u012D\\u00EF\\u1E2F\\u1EC9\\u01D0\\u0209\\u020B\\u1ECB\\u012F\\u1E2D\\u0268\\u0131',\r\n    j: '\\u006A\\u24D9\\uFF4A\\u0135\\u01F0\\u0249',\r\n    k: '\\u006B\\u24DA\\uFF4B\\u1E31\\u01E9\\u1E33\\u0137\\u1E35\\u0199\\u2C6A\\uA741\\uA743\\uA745\\uA7A3',\r\n    l: '\\u006C\\u24DB\\uFF4C\\u0140\\u013A\\u013E\\u1E37\\u1E39\\u013C\\u1E3D\\u1E3B\\u017F\\u0142\\u019A\\u026B\\u2C61\\uA749\\uA781\\uA747',\r\n    lj: '\\u01C9',\r\n    m: '\\u006D\\u24DC\\uFF4D\\u1E3F\\u1E41\\u1E43\\u0271\\u026F',\r\n    n: '\\u006E\\u24DD\\uFF4E\\u01F9\\u0144\\u00F1\\u1E45\\u0148\\u1E47\\u0146\\u1E4B\\u1E49\\u019E\\u0272\\u0149\\uA791\\uA7A5',\r\n    nj: '\\u01CC',\r\n    o: '\\u006F\\u24DE\\uFF4F\\u00F2\\u00F3\\u00F4\\u1ED3\\u1ED1\\u1ED7\\u1ED5\\u00F5\\u1E4D\\u022D\\u1E4F\\u014D\\u1E51\\u1E53\\u014F\\u022F\\u0231\\u00F6\\u022B\\u1ECF\\u0151\\u01D2\\u020D\\u020F\\u01A1\\u1EDD\\u1EDB\\u1EE1\\u1EDF\\u1EE3\\u1ECD\\u1ED9\\u01EB\\u01ED\\u00F8\\u01FF\\u0254\\uA74B\\uA74D\\u0275',\r\n    oi: '\\u01A3',\r\n    ou: '\\u0223',\r\n    oo: '\\uA74F',\r\n    p: '\\u0070\\u24DF\\uFF50\\u1E55\\u1E57\\u01A5\\u1D7D\\uA751\\uA753\\uA755',\r\n    q: '\\u0071\\u24E0\\uFF51\\u024B\\uA757\\uA759',\r\n    r: '\\u0072\\u24E1\\uFF52\\u0155\\u1E59\\u0159\\u0211\\u0213\\u1E5B\\u1E5D\\u0157\\u1E5F\\u024D\\u027D\\uA75B\\uA7A7\\uA783',\r\n    s: '\\u0073\\u24E2\\uFF53\\u00DF\\u015B\\u1E65\\u015D\\u1E61\\u0161\\u1E67\\u1E63\\u1E69\\u0219\\u015F\\u023F\\uA7A9\\uA785\\u1E9B',\r\n    t: '\\u0074\\u24E3\\uFF54\\u1E6B\\u1E97\\u0165\\u1E6D\\u021B\\u0163\\u1E71\\u1E6F\\u0167\\u01AD\\u0288\\u2C66\\uA787',\r\n    tz: '\\uA729',\r\n    u: '\\u0075\\u24E4\\uFF55\\u00F9\\u00FA\\u00FB\\u0169\\u1E79\\u016B\\u1E7B\\u016D\\u00FC\\u01DC\\u01D8\\u01D6\\u01DA\\u1EE7\\u016F\\u0171\\u01D4\\u0215\\u0217\\u01B0\\u1EEB\\u1EE9\\u1EEF\\u1EED\\u1EF1\\u1EE5\\u1E73\\u0173\\u1E77\\u1E75\\u0289',\r\n    v: '\\u0076\\u24E5\\uFF56\\u1E7D\\u1E7F\\u028B\\uA75F\\u028C',\r\n    vy: '\\uA761',\r\n    w: '\\u0077\\u24E6\\uFF57\\u1E81\\u1E83\\u0175\\u1E87\\u1E85\\u1E98\\u1E89\\u2C73',\r\n    x: '\\u0078\\u24E7\\uFF58\\u1E8B\\u1E8D',\r\n    y: '\\u0079\\u24E8\\uFF59\\u1EF3\\u00FD\\u0177\\u1EF9\\u0233\\u1E8F\\u00FF\\u1EF7\\u1E99\\u1EF5\\u01B4\\u024F\\u1EFF',\r\n    z: '\\u007A\\u24E9\\uFF5A\\u017A\\u1E91\\u017C\\u017E\\u1E93\\u1E95\\u01B6\\u0225\\u0240\\u2C6C\\uA763'\r\n};\r\nconst core = {\r\n    matcher: Object.freeze(DIACRITICS_MAP),\r\n\r\n    insensitiveMatcher: new Proxy({}, {\r\n        get(receiver, name) {\r\n            const keys = Object.keys(DIACRITICS_MAP).filter(key => (new RegExp(`^[${key}]$`, 'ui')).test(name));\r\n            if (keys.length) {\r\n                return keys.map(key => DIACRITICS_MAP[key]).join('');\r\n            }\r\n            return receiver[name];\r\n        }\r\n    }),\r\n\r\n    /**\r\n     * Group diacritics by the given RegExp\r\n     *\r\n     * @param {RegExp} regexp Matching criteria to filter diacritics\r\n     * @returns {string}\r\n     */\r\n    matcherBy(regexp) {\r\n        if (regexp instanceof RegExp) {\r\n            const keys = Object.keys(DIACRITICS_MAP).filter(key => regexp.test(key));\r\n            if (keys.length) {\r\n                return keys.map(key => DIACRITICS_MAP[key].trim()).join('');\r\n            }\r\n        }\r\n        return;\r\n    }\r\n};\r\n\r\n/**\r\n * @namespace Diacritics\r\n * @returns {Proxy}\r\n */\r\nexport default new Proxy(Object.assign({}, core, {\r\n    validator: new Proxy({}, {\r\n        get(receiver, name) {\r\n            if (typeof name  === 'string' && core.matcher[name]) {\r\n                return new RegExp(`[${core.matcher[name]}]`, 'u');\r\n            }\r\n            return receiver[name];\r\n        }\r\n    }),\r\n\r\n    insensitiveValidator: new Proxy({}, {\r\n        get(receiver, name) {\r\n            if (core.matcher[name]) {\r\n                return new RegExp(`[${core.insensitiveMatcher[name]}]`, 'ui');\r\n            }\r\n            return receiver[name];\r\n        }\r\n    })\r\n}), {\r\n    get(receiver, name) {\r\n        if (name.length === 1) {\r\n            const [normalizedLetter] = Object.values(DIACRITICS_MAP).find(value => (new RegExp(`[${value}]`, 'u')).test(name)) || [];\r\n            return normalizedLetter || name;\r\n        }\r\n        return receiver[name];\r\n    }\r\n});","const GENDERS = {\r\n    M: 0,\r\n    F: 40\r\n};\r\n\r\n/**\r\n * @namespace Gender\r\n * @property {number} M 0\r\n * @property {number} F 40\r\n * @property {function({number})} parseNumberToGender\r\n */\r\nexport default Object.freeze(new Proxy(Object.assign({}, GENDERS), {\r\n    get(receiver, name) {\r\n        if (typeof name  === 'string') {\r\n            const index = parseInt(name);\r\n            const values = this.toArray.apply(receiver);\r\n            if (!isNaN(index) && (index >= 0 && index <= 31 || index >= 40 && index <= 71)) {\r\n                return values[Math.floor(index/40)];\r\n            }\r\n            if (typeof this[name] === 'function') {\r\n                return (...args) => this[name].apply(receiver, args);\r\n            }\r\n        }\r\n        return this[name] || receiver[name];\r\n    },\r\n\r\n    /**\r\n     * Return an array of Gender constants\r\n     *\r\n     * @returns {Array<string>} List of Gender keys\r\n     * @memberof Gender\r\n     */\r\n    toArray(){\r\n        return Object.keys(this);\r\n    }\r\n}));","const OMOCODE = [\r\n    'L',\r\n    'M',\r\n    'N',\r\n    'P',\r\n    'Q',\r\n    'R',\r\n    'S',\r\n    'T',\r\n    'U',\r\n    'V'\r\n];\r\n\r\n/**\r\n * @namespace Omocode\r\n * @returns {Proxy}\r\n * @property {number} L\r\n * @property {number} M\r\n * @property {number} N\r\n * @property {number} P\r\n * @property {number} Q\r\n * @property {number} R\r\n * @property {number} S\r\n * @property {number} T\r\n * @property {number} U\r\n * @property {number} V\r\n */\r\nexport default Object.freeze(new Proxy({ OMOCODE }, {\r\n    get(receiver, name) {\r\n        if(typeof name  === 'string' && receiver.OMOCODE.includes(name)) {\r\n            return receiver.OMOCODE.indexOf(name);\r\n        }\r\n        return this[name] || receiver.OMOCODE[name] || receiver[name];\r\n    }\r\n}));","import Belfiore from './belfiore';\r\nimport BirthMonth from './birthMonth.enum';\r\nimport CheckDigitizer from './checkDigitizer';\r\nimport DATE_VALIDATOR from './dateValidator.const';\r\nimport Diacritics from './diacritics';\r\nimport Gender from './gender.enum';\r\nimport moment from 'moment';\r\nimport Omocode from './omocode.enum';\r\nimport VALIDATOR from './validator.const';\r\n\r\n/**\r\n * @namespace Parser\r\n */\r\nclass Parser {\r\n\r\n    /**\r\n     * Default omocode bitmap\r\n     * @readonly\r\n     * @returns {number} Omocode bitmap number\r\n     * @public\r\n     */\r\n    static get OMOCODE_BITMAP(){\r\n        return 0b0111011011000000;\r\n    }\r\n\r\n    /**\r\n     * Parse surname information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete Omocode/Regular CF to parse\r\n     * @returns {string|null} Regular CF w/o omocodes chars\r\n     * @public\r\n     */\r\n    static cfDeomocode(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 7) {\r\n            return codiceFiscale;\r\n        }\r\n\r\n        const checkBitmap = offset => !!(2**offset & this.OMOCODE_BITMAP);\r\n\r\n        return codiceFiscale.replace(/[\\dA-Z]/giu, (match, offset) => (/^[A-Z]$/giu).test(match) && checkBitmap(offset) ? Omocode[match] : match);\r\n    }\r\n\r\n    /**\r\n     * Parse surname information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {string|null} Partial/possible surname\r\n     * @public\r\n     */\r\n    static cfToSurname(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 3 || !(/^[A-Z]{3}/iu).test(codiceFiscale)) {\r\n            return null;\r\n        }\r\n\r\n        const surnameCf = codiceFiscale.substr(0,3);\r\n\r\n        const [cons = ''] = surnameCf.match(new RegExp(`^[${VALIDATOR.CONSONANT_LIST}]{1,3}`, 'ig')) || [];\r\n        const [vow = ''] = surnameCf.match(new RegExp(`[${VALIDATOR.VOWEL_LIST}]{1,3}`, 'ig')) || [];\r\n\r\n        const matchingLength = cons.length + vow.length;\r\n\r\n        if (matchingLength < 2 || matchingLength < 3 && surnameCf[2].toUpperCase() !== 'X') {\r\n            return null;\r\n        }\r\n\r\n        switch(cons.length) {\r\n        case 3:\r\n            return (cons + vow).split('').join('*') + '*';\r\n        case 2:\r\n            return `${cons[0]}${vow[0]}*${cons[1]}*`;\r\n        case 1:\r\n            return `${cons[0]}${vow}*`;\r\n        default:\r\n            return `${vow}${vow.length === 3 ? '*': ''}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse name information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {string|null} Partial/possible name\r\n     * @public\r\n     */\r\n    static cfToName(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 3 || !(/^[A-Z]{6}/iu).test(codiceFiscale)) {\r\n            return null;\r\n        }\r\n        return this.cfToSurname(codiceFiscale.substr(3, 3));\r\n    }\r\n\r\n    /**\r\n     * Parse gender information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {'M'|'F'|null} Male or female\r\n     * @public\r\n     */\r\n    static cfToGender(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 11) {\r\n            return null;\r\n        }\r\n        const birthDay = parseInt(codiceFiscale.substr(9,2));\r\n        if (birthDay === 0 || birthDay === 40) {\r\n            return null;\r\n        }\r\n        return Gender[birthDay];\r\n    }\r\n\r\n    /**\r\n     * Parse birth year information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {number|null} Birth Year (4 digits)\r\n     * @public\r\n     */\r\n    static cfToBirthYear(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 8) {\r\n            return null;\r\n        }\r\n        const birthYear = parseInt(codiceFiscale.substr(6,2));\r\n\r\n        if (isNaN(birthYear)) {\r\n            return null;\r\n        }\r\n\r\n        const current2DigitsYear = parseInt(moment().format('YY'));\r\n\r\n        const century = (birthYear > current2DigitsYear) * 100;\r\n        return moment().subtract(current2DigitsYear - birthYear + century, 'years').year();\r\n    }\r\n\r\n    /**\r\n     * Parse birth month information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {number|null} Birth Month (0...11 - Date notation)\r\n     * @public\r\n     */\r\n    static cfToBirthMonth(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 9) {\r\n            return null;\r\n        }\r\n\r\n        const birthMonth = BirthMonth[codiceFiscale.substr(8,1)];\r\n        if (!birthMonth && birthMonth !== 0) {\r\n            return null;\r\n        }\r\n        return birthMonth;\r\n    }\r\n\r\n    /**\r\n     * Parse birth day information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {number|null} Birth day (1..31)\r\n     * @public\r\n     */\r\n    static cfToBirthDay(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 11) {\r\n            return null;\r\n        }\r\n        let birthDay = parseInt(codiceFiscale.substr(9,2));\r\n\r\n        if (isNaN(birthDay)) {\r\n            return null;\r\n        }\r\n\r\n        birthDay -= birthDay >= 40 ? 40 : 0;\r\n\r\n        if (birthDay < 1 || birthDay > 31) {\r\n            return null;\r\n        }\r\n        return birthDay;\r\n    }\r\n\r\n    /**\r\n     * Parse birth date information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {Date|null} Birth Date\r\n     * @public\r\n     */\r\n    static cfToBirthDate(codiceFiscale) {\r\n        const birthDay = this.cfToBirthDay(codiceFiscale);\r\n        if (!birthDay) {\r\n            return null;\r\n        }\r\n\r\n        const birthMonth = this.cfToBirthMonth(codiceFiscale);\r\n        if (!birthMonth && birthMonth !== 0) {\r\n            return null;\r\n        }\r\n\r\n        const birthYear = this.cfToBirthYear(codiceFiscale);\r\n        if (!birthYear) {\r\n            return null;\r\n        }\r\n\r\n        const dt = moment(Date.UTC(birthYear, birthMonth, birthDay));\r\n        if (!dt.isValid()) {\r\n            return null;\r\n        }\r\n        return dt.toDate();\r\n    }\r\n\r\n    /**\r\n     * Parse birth place information\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {Object} {name, belfioreCode} Birth place\r\n     * @public\r\n     */\r\n    static cfToBirthPlace(codiceFiscale) {\r\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 15) {\r\n            return null;\r\n        }\r\n\r\n\r\n        const birthPlace = Belfiore[codiceFiscale.substr(11,4).toUpperCase()];\r\n        if (!birthPlace) {\r\n            return null;\r\n        }\r\n\r\n        const {creationDate, expirationDate} = birthPlace;\r\n        if (creationDate || expirationDate) {\r\n            const birthDate = this.cfToBirthDate(codiceFiscale);\r\n            if (!birthDate) {\r\n                return null;\r\n            }\r\n            let validityCheck = true;\r\n            if (creationDate) {\r\n                validityCheck = moment(birthDate).isSameOrAfter(moment(creationDate));\r\n            }\r\n            if(validityCheck && expirationDate) {\r\n                validityCheck = moment(birthDate).isSameOrBefore(moment(expirationDate));\r\n            }\r\n            if (!validityCheck) {\r\n                return null;\r\n            }\r\n        }\r\n        return birthPlace;\r\n    }\r\n\r\n    /**\r\n     * @param {string} fiscalCode 16 character Codice Fiscale to decode\r\n     * @returns {Object} {surname, name, year, month, day, gender, place} Decoded CF Info\r\n     */\r\n    static cfDecode(fiscalCode) {\r\n        const year = this.cfToBirthYear(fiscalCode),\r\n            month = this.cfToBirthMonth(fiscalCode),\r\n            day = this.cfToBirthDay(fiscalCode);\r\n        return {\r\n            surname: this.cfToSurname(fiscalCode),\r\n            name: this.cfToName(fiscalCode),\r\n\r\n            year,\r\n            month,\r\n            day,\r\n            date: new Date(Date.UTC(year, month, day)),\r\n\r\n            gender: this.cfToGender(fiscalCode),\r\n            place: (this.cfToBirthPlace(fiscalCode) || {}).name\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Normalize diacritics\r\n     * \r\n     * @param {string} text Input text to normalize\r\n     * @returns {string|null} Output text w/o diacritics\r\n     */\r\n    static removeDiacritics(text) {\r\n        if (!text || typeof text !== 'string') {\r\n            return null;\r\n        }\r\n        return text.replace(/./gu, c => Diacritics[c]);\r\n    }\r\n\r\n    /**\r\n     * Parse surname to cf part\r\n     * \r\n     * @param {string} surname Partial or complete CF to parse\r\n     * @returns {string|null} partial cf\r\n     * @public\r\n     */\r\n    static surnameToCf(surname) {\r\n        if ((surname || '').trim().length < 2) {\r\n            return null;\r\n        }\r\n        \r\n        const noDiacriticsSurname = this.removeDiacritics(surname);\r\n        const consonants = (noDiacriticsSurname.match(new RegExp(`[${VALIDATOR.CONSONANT_LIST}]+`, 'ig')) || []).join('');\r\n        const vowels = (noDiacriticsSurname.match(new RegExp(`[${VALIDATOR.VOWEL_LIST}]+`, 'ig')) || []).join('');\r\n\r\n        const partialCf = (consonants + vowels + 'X').substr(0, 3);\r\n\r\n        if (partialCf.length < 3) {\r\n            return null;\r\n        }\r\n        return partialCf.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Parse name to cf part\r\n     * \r\n     * @param {string} name Partial or complete CF to parse\r\n     * @returns {string|null} partial cf\r\n     * @public\r\n     */\r\n    static nameToCf(name) {\r\n        if ((name || '').trim().length < 2) {\r\n            return null;\r\n        }\r\n        \r\n        const noDiacriticsName = this.removeDiacritics(name);\r\n        const consonants = (noDiacriticsName.match(new RegExp(`[${VALIDATOR.CONSONANT_LIST}]+`, 'ig')) || []).join('');\r\n\r\n        if (consonants.length >= 4) {\r\n            return (consonants[0] + consonants.substr(2, 2)).toUpperCase();\r\n        }\r\n        return this.surnameToCf(name);\r\n    }\r\n\r\n    /**\r\n     * Parse year to cf part\r\n     * \r\n     * @param {string|number} year Birth year 2 or 4 digit string, number above 19XX or below 100\r\n     * @returns {string|null} partial cf\r\n     * @public\r\n     */\r\n    static yearToCf(year) {\r\n        let parsedYear = year;\r\n        if (typeof year === 'string') {\r\n            parsedYear = parseInt(year);\r\n        }\r\n        if (!(typeof parsedYear === 'number' && !isNaN(parsedYear) &&(parsedYear >= 1900 || parsedYear < 100))) {\r\n            return null;\r\n        }\r\n        return `0${parsedYear}`.substr(-2);\r\n    }\r\n\r\n    /**\r\n     * Parse month information\r\n     * \r\n     * @param {number} month Month number 0..11\r\n     * @returns {string|null} Birth Month CF code\r\n     * @public\r\n     */\r\n    static monthToCf(month) {\r\n        if (!(typeof month === 'number' && !isNaN(month))) {\r\n            return null;\r\n        }\r\n\r\n        return BirthMonth[month] || null;\r\n    }\r\n\r\n    /**\r\n     * Parse day information\r\n     * \r\n     * @param {number} day Day number 1..31\r\n     * @param {Gender|string} gender Gender enum value\r\n     * @returns {string|null} Birth Day CF code\r\n     * @public\r\n     */\r\n    static dayGenderToCf(day, gender) {\r\n        if (!(typeof day === 'number' && !isNaN(day) && (day > 0 && day < 32))) {\r\n            return null;\r\n        }\r\n        const genderValue = Gender[gender];\r\n        if (typeof genderValue !== 'number') {\r\n            return null;\r\n        }\r\n        return `0${day + genderValue}`.substr(-2);\r\n    }\r\n\r\n    /**\r\n     * Parse Year, Month, Day to Dated\r\n     * \r\n     * @param {number} year 4 digits Year\r\n     * @param {number} [month = 0] 1 or 2 digits Month 0..11\r\n     * @param {number} [day = 1] 1,2 digits Day 1..31\r\n     * @returns {Date|null} Date or null if provided year/month/day are not valid\r\n     */\r\n    static yearMonthDayToDate(year, month = 0, day = 1) {\r\n        if ([year, month, day].some(param => typeof param !== 'number') || year < 1861) {\r\n            return null;\r\n        }\r\n        const date = moment(Date.UTC(year, month, day));\r\n        if (!date.isValid() || date.year() !== year || date.month() !== month || date.date() !== day) {\r\n            return null;\r\n        }\r\n        return date.toDate();\r\n    }\r\n\r\n    /**\r\n     * Parse a Dated and Gender information to create Date/Gender CF part\r\n     * \r\n     * @param {Date|Moment|string|Array<number>} date Date or Moment instance, ISO8601 date string or array of numbers [year, month, day]\r\n     * @returns {Date|null} Parsed Date or null if not valid\r\n     * @public\r\n     */\r\n    static parseDate(date) {\r\n        if (!(\r\n            date instanceof Date ||\r\n            date instanceof moment ||\r\n            typeof date === 'string' && (new RegExp(DATE_VALIDATOR.ISO8601_SHORT_DATE)).test(date) ||\r\n            Array.isArray(date) && !date.some(value => typeof value !== 'number')\r\n        )) {\r\n            return null;\r\n        }\r\n\r\n        const parsedDate = moment(date);\r\n        if (!parsedDate.isValid()){\r\n            return null;\r\n        }\r\n        return parsedDate.toDate();\r\n    }\r\n\r\n    /**\r\n     * Parse a Dated and Gender information to create Date/Gender CF part\r\n     * \r\n     * @param {Date|Moment|string|Array<number>} date Date or Moment instance, ISO8601 date string or array of numbers [year, month, day]\r\n     * @param {Gender|string} gender Gender enum value\r\n     * @returns {string|null} Birth date and Gender CF code\r\n     * @public\r\n     */\r\n    static dateGenderToCf(date, gender) {\r\n        if (!Gender.hasOwnProperty(gender)) {\r\n            return null;\r\n        }\r\n        const parsedDate = this.parseDate(date);\r\n        if (!parsedDate) {\r\n            return null;\r\n        }\r\n        \r\n        const cfYear = this.yearToCf(parsedDate.getFullYear());\r\n        const cfMonth = this.monthToCf(parsedDate.getMonth());\r\n        const cfDayGender = this.dayGenderToCf(parsedDate.getDate(), gender);\r\n\r\n        return `${cfYear}${cfMonth}${cfDayGender}`;\r\n    }\r\n\r\n    /**\r\n     * Parse a Dated and Gender information to create Date/Gender CF part\r\n     * \r\n     * @param {Date|Moment|string|Array<number>} date Date or Moment instance, ISO8601 date string or array of numbers [year, month, day]\r\n     * @param {string} name City or Country name\r\n     * @param {string} [province] Province code for cities\r\n     * @returns {string|null} Matching place belfiore code, if only once is matching criteria\r\n     * @public\r\n     *//**\r\n     * Parse place name and province to Belfiore code\r\n     * @param {string} name City or Country name\r\n     * @param {string} [province] Province code for cities\r\n     * @returns {string|null} Matching place belfiore code, if only once is matching criteria\r\n     * @public\r\n     */\r\n    static placeToCf(...args) {\r\n        let targetDate = this.parseDate(args[0]);\r\n\r\n        let [name, province] = args.filter(input => typeof input === 'string');\r\n        if (!province) {\r\n            return (Belfiore.active(targetDate).findByName(name) || {}).belfioreCode;\r\n        }\r\n        const results = Belfiore.searchByName(name).toArray().filter(place => province.trim().toUpperCase() === place.province);\r\n        if (results.length === 1) {\r\n            return results[0].belfioreCode;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Generates full CF\r\n     * \r\n     * @param {Object} input Input Object\r\n     * @param {string} input.surname Surname\r\n     * @param {string} input.name Name\r\n     * @param {number} [input.year] Birth Year\r\n     * @param {number} [input.month] Birth Month\r\n     * @param {number} [input.day] Birth Day\r\n     * @param {Date|Moment} [input.date] Birth Date\r\n     * @param {Gender|string} input.gender Gender M|F\r\n     * @param {string} input.place Place name\r\n     * @returns {string|null} Complete CF\r\n     */\r\n    static encodeCf({\r\n        surname,\r\n        name,\r\n\r\n        year,\r\n        month,\r\n        day,\r\n        date,\r\n\r\n        gender,\r\n        place\r\n    }) {\r\n        const dtParams = this.parseDate(date) || this.yearMonthDayToDate(year, month, day);\r\n        const generator = [\r\n            () => this.surnameToCf(surname),\r\n            () => this.nameToCf(name),\r\n            () => this.dateGenderToCf(dtParams, gender),\r\n            () => this.placeToCf(dtParams, place),\r\n            () => CheckDigitizer.checkDigit(cf)\r\n        ];\r\n        let cf = '';\r\n        for (let i=0; i<generator.length; i++) {\r\n            const cfValue = generator[i]();\r\n            if (!cfValue) {\r\n                return null;\r\n            }\r\n            cf += cfValue;\r\n        }\r\n\r\n        return cf;\r\n    }\r\n}\r\n\r\nexport default Parser;","import CheckDigitizer from './checkDigitizer';\r\nimport DATE_VALIDATOR from './dateValidator.const';\r\nimport Diacritics from './diacritics';\r\nimport Gender from './gender.enum';\r\nimport moment from 'moment';\r\nimport Omocode from './omocode.enum';\r\nimport Parser from './parser';\r\nimport VALIDATOR from './validator.const';\r\n\r\n/**\r\n * @namespace Validator\r\n */\r\nclass Validator {\r\n\r\n    /**\r\n     * Validation regexp for the given surname or generic\r\n     * @param {string} surname Optional surname to generate validation regexp\r\n     * @returns {RegExp} CF Surname matcher\r\n     * @public\r\n     */\r\n    static cfSurname(surname) {\r\n        let matcher = VALIDATOR.NAME_MATCHER;\r\n        if (surname) {\r\n            matcher = Parser.surnameToCf(surname) || matcher;\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Validation regexp for the given name or generic\r\n     * @param {string} name Optional name to generate validation regexp\r\n     * @returns {RegExp} CF name matcher\r\n     * @public\r\n     */\r\n    static cfName(name) {\r\n        let matcher = VALIDATOR.NAME_MATCHER;\r\n        if (name) {\r\n            matcher = Parser.nameToCf(name) || matcher;\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Validation regexp for the given year or generic\r\n     * @param {number} year Optional year to generate validation regexp\r\n     * @returns {RegExp} CF year matcher\r\n     * @public\r\n     */\r\n    static cfYear(year) {\r\n        let matcher = VALIDATOR.YEAR_MATCHER;\r\n        if (year) {\r\n            const parsedYear = Parser.yearToCf(year);\r\n            if (parsedYear) {\r\n                matcher = parsedYear.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Validation regexp for the given month or generic\r\n     * @param {number} month Optional month to generate validation regexp\r\n     * @returns {RegExp} CF month matcher\r\n     * @public\r\n     */\r\n    static cfMonth(month) {\r\n        let matcher = VALIDATOR.MONTH_MATCHER;\r\n        if (month) {\r\n            matcher = Parser.monthToCf(month) || matcher;\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Validation regexp for the given year or generic\r\n     * @param {number} day Optional day to generate validation regexp\r\n     * @returns {RegExp} CF day matcher\r\n     * @public\r\n     */\r\n    static cfDay(day) {\r\n        let matcher = VALIDATOR.DAY_MATCHER;\r\n        if (day) {\r\n            const parsedDayM = Parser.dayGenderToCf(day, 'M');\r\n            if (parsedDayM) {\r\n                const matcherM = parsedDayM.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n                const matcherF = Parser.dayGenderToCf(day, 'F').replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n                matcher = `(?:${matcherM})|(?:${matcherF})`;\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Validation regexp for the given year or generic\r\n     * @param {number} day Optional day to generate validation regexp\r\n     * @param {'M'|'F'} [gender] Gender @see Gender\r\n     * @returns {RegExp} CF day and gender matcher\r\n     * @public\r\n     */\r\n    static cfDayGender(day, gender) {\r\n        if (!gender) {\r\n            return this.cfDay(day);\r\n        }\r\n        let matcher;\r\n        if (day) {\r\n            const parsedDayGender = Parser.dayGenderToCf(day, gender);\r\n            if (parsedDayGender) {\r\n                matcher = parsedDayGender.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n            } else {\r\n                throw new Error('[Validator.cfDayGender] Provided day is not valid');\r\n            }\r\n        } else {\r\n            switch (gender) {\r\n            case 'M':\r\n                matcher = VALIDATOR.MALE_DAY_MATCHER;\r\n                break;\r\n            case 'F':\r\n                matcher = VALIDATOR.FEMALE_DAY_MATCHER;\r\n                break;\r\n            default:\r\n                throw new Error('[Validator.cfDayGender] Provided gender is not valid');\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Validation regexp for the given year or generic\r\n     * @param {Date|Moment|Array<number>} date Optional date to generate validation regexp\r\n     * @param {'M'|'F'} [gender] @see Gender\r\n     * @returns {RegExp} CF date and gender matcher\r\n     * @public\r\n     */\r\n    static cfDateGender(date, gender) {\r\n        let matcher = VALIDATOR.FULL_DATE_MATCHER;\r\n        if (date && gender) {\r\n            const parsedDateGender = Parser.dateGenderToCf(date, gender);\r\n            if (parsedDateGender) {\r\n                matcher = parsedDateGender.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n            } else {\r\n                throw new Error('[Validator.cfDateGender] Provided date is not valid');\r\n            }\r\n        } else if (gender) {\r\n            switch (gender) {\r\n            case 'M':\r\n                matcher = VALIDATOR.MALE_FULL_DATE_MATCHER;\r\n                break;\r\n            case 'F':\r\n                matcher = VALIDATOR.FEMALE_FULL_DATE_MATCHER;\r\n                break;\r\n            default:\r\n                throw new Error('[Validator.cfDateGender] Provided gender is not valid');\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * @param {string} placeName Optional place name to generate validation regexp\r\n     * @returns {RegExp} CF place matcher\r\n     * @public\r\n     *//**\r\n     * @param {Date|Moment|Array<number>} [date] Optional date to generate validation regexp\r\n     * @param {string} placeName Optional place name to generate validation regexp\r\n     * @returns {RegExp} CF place matcher\r\n     * @public\r\n     */\r\n    static cfPlace(...args) {\r\n        let matcher = VALIDATOR.BELFIORE_CODE_MATCHER;\r\n        if (args.filter(param => !!param).length > moment(args[0]).isValid()) {\r\n            const parsedPlace = Parser.placeToCf(...args);\r\n            if (parsedPlace) {\r\n                matcher = parsedPlace.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n            } else {\r\n                matcher = '';\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Generates full CF validator based on given optional input or generic\r\n     * \r\n     * @param {Object} input Input Object\r\n     * @param {string} input.surname Surname\r\n     * @param {string} input.name Name\r\n     * @param {number} [input.year] Birth Year\r\n     * @param {number} [input.month] Birth Month\r\n     * @param {number} [input.day] Birth Day\r\n     * @param {Date|Moment} [input.date] Birth Date\r\n     * @param {Gender|string} input.gender Gender M|F\r\n     * @param {string} input.place Place name\r\n     * @returns {RegExp} CodiceFiscale matcher\r\n     */\r\n    static codiceFiscale(input) {\r\n        let matcher = VALIDATOR.CODICE_FISCALE;\r\n        if (input) {\r\n            const parsedCf = Parser.encodeCf(input);\r\n\r\n            if (parsedCf) {\r\n                matcher = parsedCf.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\r\n            } else {\r\n                const { surname, name, year, month, day, date, gender, place } = input;\r\n                if (surname || name || year || month || day || date || gender || place) {\r\n                    const dtParams = Parser.parseDate(date) || Parser.yearMonthDayToDate(year, month, day);\r\n                    const generator = [\r\n                        () => this.cfSurname(surname),\r\n                        () => this.cfName(name),\r\n                        () => this.cfDateGender(dtParams, gender),\r\n                        () => this.cfPlace(dtParams, place)\r\n                    ];\r\n\r\n                    matcher = '';\r\n                    for (let i=0; i<generator.length; i++) {\r\n                        const cfPartValidator = generator[i]();\r\n                        if (!cfPartValidator) {\r\n                            break;\r\n                        }\r\n                        const cfValue = (cfPartValidator.toString().match(/\\^(.+)\\$/) || [])[1];\r\n                        if (!cfValue) {\r\n                            break;\r\n                        }\r\n                        matcher += `(?:${cfValue})`;\r\n                    }\r\n                    // Final addition of CheckDigit\r\n                    matcher += VALIDATOR.CHECK_DIGIT;\r\n                }\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns surname validator based on given cf or generic\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {RegExp} Generic or specific regular expression\r\n     * @public\r\n     */\r\n    static surname(codiceFiscale) {\r\n        const ANY_LETTER = `[${Diacritics.matcherBy(/^[A-Z]$/ui)}]`;\r\n        let matcher = `${ANY_LETTER}+`;\r\n        if (typeof codiceFiscale === 'string' && (/^[A-Z]{1,3}/iu).test(codiceFiscale)) {\r\n            const surnameCf = codiceFiscale.substr(0,3);\r\n            \r\n            const diacriticizer = matchingChars => (matchingChars || '').split('').map(char => `[${Diacritics.insensitiveMatcher[char]}]`);\r\n\r\n            const matchFromCf = (cf, charMatcher) => diacriticizer((cf.match(new RegExp(charMatcher, 'ig')) || [])[0]);\r\n\r\n            const cons = matchFromCf(surnameCf, `^[${VALIDATOR.CONSONANT_LIST}]{1,3}`);\r\n            const vow = matchFromCf(surnameCf, `[${VALIDATOR.VOWEL_LIST}]{1,3}`);\r\n            \r\n            const diacriticsVowelList = Diacritics.matcherBy(new RegExp(`^[${VALIDATOR.VOWEL_LIST}]$`, 'ui'));\r\n\r\n            switch(cons.length) {\r\n            case 3:\r\n                matcher = cons.join(`[${diacriticsVowelList}]*`) + `${ANY_LETTER}*`;\r\n                break;\r\n            case 2: {\r\n                const possibilities = [\r\n                    `${vow[0]}${cons[0]}[${diacriticsVowelList}]*${cons[1]}`,\r\n                    `${cons[0]}${vow.join('')}[${diacriticsVowelList}]*${cons[1]}`,\r\n                    `${cons.join('')}${vow[0]}`\r\n                ];\r\n                matcher = `(?:${possibilities.join('|')})[${diacriticsVowelList}]*`;\r\n                break;\r\n            }\r\n            case 1: {\r\n                const possibilities = [\r\n                    `${vow.slice(0,2).join('')}[${diacriticsVowelList}]*${cons}`,\r\n                    `${vow[0]}${cons}${vow[1]}`,\r\n                    `${cons[0]+vow.slice(0,2).join('')}`\r\n                ];\r\n                matcher = `(?:${possibilities.join('|')})[${diacriticsVowelList}]*`;\r\n                break;\r\n            }\r\n            default:\r\n                matcher = `${vow.join('')}[${diacriticsVowelList}]*`;\r\n            }\r\n        }\r\n\r\n        return new RegExp(`^${matcher}$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Returns name validator based on given cf or generic\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {RegExp} Generic or specific regular expression\r\n     * @public\r\n     */\r\n    static name(codiceFiscale) {\r\n        if (typeof codiceFiscale === 'string' && (new RegExp(`^[A-Z]{3}[${VALIDATOR.CONSONANT_LIST}]{3}`, 'iu')).test(codiceFiscale)) {\r\n            const ANY_LETTER = `[${Diacritics.matcherBy(/^[A-Z]$/ui)}]`;\r\n\r\n            const nameCf = codiceFiscale.substr(3,3);\r\n\r\n            const cons = ((nameCf.match(new RegExp(`^[${VALIDATOR.CONSONANT_LIST}]{1,3}`, 'ig')) || [])[0] || '')\r\n                .split('').map(char => `[${Diacritics.insensitiveMatcher[char]}]`);\r\n\r\n            const diacriticsVowelList = Diacritics.matcherBy(new RegExp(`^[${VALIDATOR.VOWEL_LIST}]$`, 'ui'));\r\n            const diacriticsConsonantList = Diacritics.matcherBy(new RegExp(`^[${VALIDATOR.CONSONANT_LIST}]$`, 'ui'));\r\n\r\n            const matcher = `[${diacriticsVowelList}]*${cons[0]}[${diacriticsVowelList}]*(?:[${diacriticsConsonantList}][${diacriticsVowelList}]*)?`\r\n                + cons.slice(1,3).join(`[${diacriticsVowelList}]*`) + `${ANY_LETTER}*`;\r\n            \r\n            return new RegExp(`^${matcher}$`, 'iu');\r\n        }\r\n        return this.surname((codiceFiscale || '').substr(3,3));\r\n    }\r\n\r\n    /**\r\n     * Returns iso8601 date validator based on given cf or generic\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {RegExp} Generic or specific regular expression\r\n     * @public\r\n     */\r\n    static date(codiceFiscale){\r\n        let matcher = DATE_VALIDATOR.ISO8601_DATE_TIME;\r\n        if (codiceFiscale) {\r\n            const parsedDate = Parser.cfToBirthDate(codiceFiscale);\r\n            if (parsedDate) {\r\n                const dateIso8601 = parsedDate.toJSON();\r\n                if (moment().diff(moment(parsedDate), 'y') < 50) {\r\n                    const century = parseInt(dateIso8601.substr(0,2));\r\n                    const centuries = [\r\n                        century -1,\r\n                        century\r\n                    ].map(year => year.toString().padStart(2, 0));\r\n                    matcher = `(?:${centuries.join('|')})` + dateIso8601.substr(2,8);\r\n                } else {\r\n                    matcher = dateIso8601.substr(0,10);\r\n                }\r\n            }\r\n        }\r\n        return new RegExp(`^${matcher}(?:T${DATE_VALIDATOR.TIME}(?:${DATE_VALIDATOR.TIMEZONE})?)?$`, 'iu');\r\n    }\r\n\r\n    /**\r\n     * Returns gender validator based on given cf or generic\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {RegExp} Generic or specific regular expression\r\n     * @public\r\n     */\r\n    static gender(codiceFiscale) {\r\n        const parsedGender = Parser.cfToGender(codiceFiscale);\r\n        const matcher = parsedGender || `[${Gender.toArray().join('')}]`;\r\n        return new RegExp(`^${matcher}$`, 'u');\r\n    }\r\n\r\n    \r\n\r\n    /**\r\n     * Returns place validator based on given cf or generic\r\n     * \r\n     * @param {string} codiceFiscale Partial or complete CF to parse\r\n     * @returns {RegExp} Generic or specific regular expression\r\n     * @public\r\n     */\r\n    static place(codiceFiscale) {\r\n        let matcher = '.+';\r\n        const parsedPlace = Parser.cfToBirthPlace(codiceFiscale);\r\n\r\n        if (parsedPlace) {\r\n            const nameMatcher = parsedPlace.name.replace(/./gu, c => Diacritics[c]===c ? c : `[${c}${Diacritics[c]}]`);\r\n            matcher = `(?:(?:${nameMatcher})|${parsedPlace.belfioreCode})`;\r\n        }\r\n\r\n        return new RegExp(`^${matcher}$`, 'ui');\r\n    }\r\n\r\n    /**\r\n     * Check the given cf validity by form, birth date/place and digit code\r\n     * \r\n     * @param {string} codiceFiscale Complete CF to parse\r\n     * @returns {boolean} Generic or specific regular expression\r\n     * @public\r\n     */\r\n    static isValid(codiceFiscale) {\r\n        const matcher = new RegExp(`^(?:${VALIDATOR.CODICE_FISCALE})$`, 'ui');\r\n        if (\r\n            // Checking form validity\r\n            !matcher.test(codiceFiscale) ||\r\n            //Checking 16th char check digit validity\r\n            codiceFiscale.substr(15, 1).toUpperCase() !== CheckDigitizer.checkDigit(codiceFiscale) ||\r\n            //Checking Birth date/place validity\r\n            !Parser.cfToBirthPlace(codiceFiscale)\r\n        ) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nexport default Validator;","import BirthMonth from './birthMonth.enum';\r\nimport Belfiore from './belfiore';\r\nimport CheckDigitizer from './checkDigitizer';\r\nimport DATE_VALIDATOR from './dateValidator.const';\r\nimport Diacritics from './diacritics';\r\nimport Gender from './gender.enum';\r\nimport Omocode from './omocode.enum';\r\nimport Parser from './parser';\r\nimport Validator from './validator';\r\nimport VALIDATOR from './validator.const';\r\n\r\n/**\r\n * @module CodiceFiscaleUtils\r\n */\r\nexport {\r\n    /**\r\n     * {@link Belfiore}\r\n     */\r\n    Belfiore,\r\n    /**\r\n     * {@link BirthMonth}\r\n     */\r\n    BirthMonth,\r\n    /**\r\n     * {@link CheckDigitizer}\r\n     */\r\n    CheckDigitizer,\r\n    /**\r\n     * {@link DATE_VALIDATOR}\r\n     */\r\n    DATE_VALIDATOR,\r\n    /**\r\n     * {@link Diacritics}\r\n     */\r\n    Diacritics,\r\n    /**\r\n     * {@link Gender}\r\n     */\r\n    Gender,\r\n    /**\r\n     * {@link Omocode}\r\n     */\r\n    Omocode,\r\n    /**\r\n     * {@link Parser}\r\n     */\r\n    Parser,\r\n    /**\r\n     * {@link VALIDATOR}\r\n     */\r\n    VALIDATOR,\r\n    /**\r\n     * {@link Validator}\r\n     */\r\n    Validator\r\n};"],"sourceRoot":""}