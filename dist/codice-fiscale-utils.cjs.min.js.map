{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"moment\"","webpack:///external \"@marketto/diacritic-remover\"","webpack:///./src/birthMonth.enum.js","webpack:///./src/belfiore.js","webpack:///./src/validator.const.js","webpack:///./src/checkDigitizer.js","webpack:///./src/dateValidator.const.js","webpack:///./src/gender.enum.js","webpack:///./src/omocode.enum.js","webpack:///./src/parser.js","webpack:///./src/error.js","webpack:///./src/validator.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","birthMonth_enum","freeze","Proxy","MONTHS","[object Object]","receiver","monthCode","toUpperCase","includes","indexOf","this","belfiore_BelfioreConnector","data","licenses","activeDate","codeMatcher","province","Error","hiddenValueConf","configurable","writable","defineProperties","_data","_licenses","_activeDate","_codeMatcher","_province","constructor","map","resource","Array","from","belfioreCode","length","e","locationByIndex","reduce","a","b","concat","filter","output","g","resourceData","indexer","indexByName","index","roundItem","push","matcher","RegExp","date","external_moment_default","code","test","cities","countries","paramName","base32name","belfioreToInt","toString","padStart","binaryfindIndex","text","start","end","rangedStart","rangedEnd","currentLength","targetIndex","Math","floor","targetValure","substr","ceil","goAhead","upperCaseCode","charCodeAt","parseInt","String","fromCharCode","base32daysFrom1861","add","list","startIndex","endIndex","counter","substring","regExpMatcher","seekEntryEndIndex","entryIndex","targetName","belfioreIndex","belFioreInt","belfioreFromInt","provinceOrCountry","dateIndex","creationDate","decodeDate","startOf","expirationDate","endOf","isBefore","isAfter","nameByIndex","isCountry","dataSource","assign","toDate","iso3166","Belfiore","cities_countries","CF_NAME_MATCHER","CF_FULL_NAME_MATCHER","LEAP_YEAR_MATCHER","DAY_29_MATCHER","DAY_MATCHER","MONTH_DAY_MATCHER","FULL_DATE_MATCHER","MALE_FULL_DATE_MATCHER","FEMALE_FULL_DATE_MATCHER","BELFIORE_CODE_MATCHER","CODICE_FISCALE","PARTIAL_CF_FULL_NAME","PARTIAL_FULL_DATE","PARTIAL_CF","validator_const","CONSONANT_LIST","VOWEL_LIST","OMOCODE_NUMBER_LIST","OMOCODE_NON_ZERO_NUMBER_LIST","OMOCODE_ZERO_LIST","MONTH_LIST","MONTH_30DAYS_LIST","MONTH_31DAYS_LIST","CITY_CODE_LIST","COUNTRY_CODE_LIST","CF_SURNAME_MATCHER","YEAR_MATCHER","MONTH_MATCHER","DAY_30_MATCHER","DAY_31_MATCHER","MALE_DAY_MATCHER","FEMALE_DAY_MATCHER","CITY_CODE_MATCHER","COUNTRY_CODE_MATCHER","CHECK_DIGIT","PARTIAL_CF_NAME_MATCHER","PARTIAL_YEAR","PARTIAL_MONTH_DAY","PARTIAL_BELFIORE_CODE_MATCHER","CONTROL_CODE_IN","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","checkDigitizer","partialCF","split","char","isNumber","codiceFiscale","partialCfValue","charValue","evaluateChar","YEAR","MONTH","MONTH_DAY","HOURS","TIMEZONE","TIME","ISO8601_SHORT_DATE","ISO8601_DATE_TIME","dateValidator_const","DAY","LEAP_MONTH","DAYS_30_MONTHS","DAYS_31_MONTHS","MINUTES","SECONDS","MILLISECONDS","gender_enum","values","toArray","apply","isNaN","args","keys","omocode_enum","OMOCODE","omocodeChar","parser","OMOCODE_BITMAP","checkBitmap","offset","replace","match","surnameCf","cons","vow","matchingLength","join","cfToSurname","birthDay","birthYear","current2DigitsYear","format","century","subtract","year","birthMonth","cfToBirthDay","cfToBirthMonth","cfToBirthYear","dt","Date","UTC","isValid","birthPlace","birthDate","cfToBirthDate","validityCheck","isSameOrAfter","isSameOrBefore","fiscalCode","month","day","surname","cfToName","gender","cfToGender","place","cfToBirthPlace","trim","noDiacriticsSurname","diacritic_remover_default","partialCf","padEnd","consonants","surnameToCf","parsedYear","genderValue","some","param","isArray","parsedDate","parseDate","yearToCf","getFullYear","monthToCf","getMonth","dayGenderToCf","getDate","targetDate","input","active","findByName","results","searchByName","dtParams","yearMonthDayToDate","generator","nameToCf","dateGenderToCf","placeToCf","checkDigit","cf","cfValue","ERRORS","INVALID_SURNAME","INVALID_NAME","INVALID_DAY","INVALID_GENDER","INVALID_DAY_OR_GENDER","INVALID_YEAR","INVALID_DATE","src_error","className","methodName","entries","accumulator","err","validator","error","parsedDayM","cfDay","parsedDayGender","omocodeReplacer","parsedDateGender","parsedPlace","parsedCf","encodeCf","cfSurname","cfName","cfDateGender","cfPlace","diacriticRemover","LETTER_SET","matcherBy","diacriticizer","matchingChars","insensitiveMatcher","matchFromCf","charMatcher","diacriticsVowelMatcher","midDiacriticVowelMatcher","endingDiacritcVowelMatcher","divider","slice","ANY_LETTER","chars","diacriticsVowelList","diacriticsConsonantList","dateIso8601","toJSON","diff","__webpack_exports__"],"mappings":"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","file":"codice-fiscale-utils.cjs.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"moment\");","module.exports = require(\"@marketto/diacritic-remover\");","const MONTHS = [\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'H',\n    'L',\n    'M',\n    'P',\n    'R',\n    'S',\n    'T'\n];\n/**\n * @namespace BirthMonth\n * @property {number} A 0\n * @property {number} B 1\n * @property {number} C 2\n * @property {number} D 3\n * @property {number} E 4\n * @property {number} H 5\n * @property {number} L 6\n * @property {number} M 7\n * @property {number} P 8\n * @property {number} R 9\n * @property {number} S 10\n * @property {number} T 11\n */\nexport default Object.freeze(new Proxy({ MONTHS }, {\n    get(receiver, name) {\n        if (typeof name  === 'string'){\n            const monthCode = name.toUpperCase();\n            if(receiver.MONTHS.includes(monthCode)) {\n                return receiver.MONTHS.indexOf(monthCode);\n            }\n        }\n        return this[name] || receiver.MONTHS[name] || receiver[name];\n    }\n}));","import CITIES_COUNTRIES from './asset/cities-countries.json';\nimport moment from 'moment';\n\n/**\n * Handler for cities and countries Dataset\n * \n * @namespace Belfiore\n */\nclass BelfioreConnector {\n    /**\n     * \n     * @param {Object} param Static json\n     * @param {Array<Array<Object>>} param.data Resource data\n     * @param {Array<Array<Object>>} param.licenses License array\n     * @constructor\n     * @private\n     */\n    constructor({ data, licenses, activeDate, codeMatcher, province }) {\n        if (codeMatcher && province) {\n            throw new Error('Both codeMatcher and province were provided to Bolfiore, only one is allowed');\n        }\n        const hiddenValueConf = value => ({\n            value,\n            enumerable: false,\n            configurable: false,\n            writable: false\n        });\n\n        Object.defineProperties(this, {\n            _data: hiddenValueConf(data),\n            _licenses: hiddenValueConf(licenses),\n            _activeDate: hiddenValueConf(activeDate),\n            _codeMatcher: hiddenValueConf(codeMatcher),\n            _province: hiddenValueConf(province)\n        });\n        return new Proxy(this, this.constructor);\n    }\n\n    /**\n     * @returns {Array<Object>} List of places\n     * @public\n     */\n    toArray() {\n        return this._data\n            .map(resource => Array.from(new Array(resource.belfioreCode.length / 3), (e, i) => this.constructor.locationByIndex(resource, i, {\n                activeDate: this._activeDate,\n                codeMatcher: this._codeMatcher,\n                province: this._province,\n                licenses: this._licenses\n            })))\n            .reduce((a, b) => a.concat(b))\n            .filter(e => !!e);\n    }\n\n    /**\n     * Search places matching given name\n     * @param {string} name Place name\n     * @returns {Array<Object>} List of places\n     * @public\n     */\n    searchByName(name) {\n        if (!name || typeof name !== 'string') {\n            return null;\n        }\n        let output = [];\n        for (let g = 0; g < this._data.length; g++) {\n            const resourceData = this._data[g];\n            const indexer = this.constructor.indexByName(resourceData.name, name);\n            for (let index of indexer) {\n                if (index >= 0) {\n                    const roundItem = this.constructor.locationByIndex(resourceData, index, {\n                        activeDate: this._activeDate,\n                        codeMatcher: this._codeMatcher,\n                        province: this._province,\n                        licenses: this._licenses\n                    });\n                    if (roundItem) {\n                        output.push(roundItem);\n                    }\n                }\n            }\n        }\n        return output;\n    }\n\n    /**\n     * Find place matching given name, retuns place object if provided name match only 1 result\n     * @param {string} name Place name\n     * @returns {Object|null}\n     * @public\n     */\n    findByName(name) {\n        if (!name || typeof name !== 'string') {\n            return null;\n        }\n        const matcher = new RegExp(`^${name}$`, 'i');\n        for (let g = 0; g < this._data.length; g++) {\n            const resourceData = this._data[g];\n            const indexer = this.constructor.indexByName(resourceData.name, matcher);\n            for (let index of indexer) {\n                if (index >= 0) {\n                    const roundItem = this.constructor.locationByIndex(resourceData, index, {\n                        activeDate: this._activeDate,\n                        codeMatcher: this._codeMatcher,\n                        province: this._province,\n                        licenses: this._licenses\n                    });\n                    if (roundItem) {\n                        return roundItem;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns a Proxied version of Belfiore which filters results by given date\n     * @param {string|Date|Moment|Array<number>} [date = moment()] Target date to filter places active only for the given date\n     * @returns {BelfioreConnector} Belfiore instance filtered by active date\n     * @public\n     */\n    active(date = moment()) {\n        const { _data, _licenses, _codeMatcher, _province } = this;\n        return new BelfioreConnector({\n            data: _data,\n            licenses: _licenses,\n            activeDate: moment(date),\n            province: _province,\n            codeMatcher: _codeMatcher\n        });\n    }\n\n    /**\n     * Returns a Belfiore instance filtered by the given province\n     * @param {string} code Province Code (2 A-Z char)\n     * @returns {BelfioreConnector} Belfiore instance filtered by province code\n     * @public\n     */\n    byProvince(code) {\n        if (!(typeof code === 'string' && (/^[A-Z]{2}$/u).test(code))) {\n            return;\n        }\n        const { _data, _licenses, _activeDate } = this;\n        return new BelfioreConnector({\n            data: _data,\n            licenses: _licenses,\n            activeDate: _activeDate,\n            province: code\n        });\n    }\n\n    /**\n     * Returns a Proxied version of Belfiore which filters results by place type\n     * @readonly\n     * @returns {Belfiore} Belfiore instance filtered by cities\n     * @public\n     */\n    get cities() {\n        const { _data, _licenses, _activeDate } = this;\n        return new BelfioreConnector({\n            data: _data,\n            licenses: _licenses,\n            activeDate: _activeDate,\n            codeMatcher: /^[A-Y]/u\n        });\n    }\n\n    /**\n     * Returns a Proxied version of Belfiore which filters results by place type\n     * @readonly\n     * @returns {BelfioreConnector} Belfiore instance filtered by countries\n     * @public\n     */\n    get countries() {\n        const { _data, _licenses, _activeDate } = this;\n        return new BelfioreConnector({\n            data: _data,\n            licenses: _licenses,\n            activeDate: _activeDate,\n            codeMatcher: /^Z/u\n        });\n    }\n\n    /**\n     * Get Proxy\n     * @param {Object} resource target resource\n     * @param {string|number|Symbol} paramName property name to proxy\n     * @returns {*} Proxied property\n     * @private\n     */\n    static get (resource, paramName) {\n        if (typeof paramName  === 'string' && (/^[A-Z]\\d{3}$/iu).test(paramName)){\n            const base32name = this.belfioreToInt(paramName).toString(32).padStart(3, '0');\n            for (let g = 0; g < resource._data.length; g++) {\n                const resourceData = resource._data[g];\n                const index = this.binaryfindIndex(resourceData.belfioreCode, base32name);\n                if (index >= 0) {\n                    return this.locationByIndex(resourceData, index, {\n                        activeDate: resource._activeDate,\n                        codeMatcher: resource._codeMatcher,\n                        province: resource._province,\n                        licenses: resource._licenses\n                    });\n                }\n            }\n        }\n\n        if (\n            \n            (resource._codeMatcher || resource._province) &&\n                ['cities', 'countries'].includes(paramName)\n             ||\n            \n                paramName === 'byProvince' &&\n                (\n                    (resource._codeMatcher instanceof RegExp && resource._codeMatcher.test('Z000')) \n                    || resource._province\n                )\n            \n        ) {\n            return;\n        }\n\n        return resource[paramName];\n    }\n\n    /**\n     * Binary find Index (works ONLY in sorted arrays)\n     * @param {string} text Unique string of values of the same length (step)\n     * @param {string} value Exact text to find\n     * @param {number} start text start index for seeking the value\n     * @param {number} end text end index for seeking the value\n     * @param {number} step length of a single value to seek properly the text string\n     * @returns {number} Found value Index or -1 if not found\n     * @private\n     */\n    static binaryfindIndex(text, value, start, end) {\n        if (typeof text !== 'string' || !text.length) {\n            return -1;\n        }\n        const rangedStart = (!start || start < 0) ? 0 : start;\n        const rangedEnd = (!end || end >= text.length) ? (text.length - 1) : end;\n        const currentLength = rangedEnd - rangedStart + 1;\n        if (rangedStart > rangedEnd || currentLength % value.length) {\n            return -1;\n        }\n        const targetIndex = rangedStart + Math.floor(currentLength/(2*value.length))*value.length;\n        const targetValure = text.substr(targetIndex, value.length);\n        if (targetValure === value) {\n            return Math.ceil((targetIndex + 1) / value.length) -1;\n        }\n        const goAhead = value > targetValure;\n        return this.binaryfindIndex(text, value, goAhead ? targetIndex + value.length : rangedStart, goAhead ? rangedEnd : targetIndex - 1);\n    }\n\n    /**\n     * Converts belfiore code into an int\n     * @param {string} code Belfiore Code\n     * @returns {number} Int version of belfiore code\n     * @private\n     */\n    static belfioreToInt(code) {\n        const upperCaseCode = code.toUpperCase();\n        return (upperCaseCode.charCodeAt()-65)*10**3 + parseInt(upperCaseCode.substr(1));\n    }\n\n    /**\n     * Converts int to belfiore code\n     * @param {number} code Belfiore int code\n     * @returns {string} Standard belfiore code\n     * @private\n     */\n    static belfioreFromInt(code) {\n        return `${String.fromCharCode(Math.floor(code / 10**3) + 65)}${code.toString().substr(-3).padStart(3, '0')}`;\n    }\n\n    /**\n     * Converst Base 32 number of days since 01/01/1861 to Moment instance\n     * @param {string} base32daysFrom1861 Base 32 number of days from 1861-01-01\n     * @returns {Moment} Moment instance date\n     * @private\n     */\n    static decodeDate(base32daysFrom1861) {\n        return moment('1861-01-01').add(parseInt(base32daysFrom1861, 32) ,'days');\n    }\n\n    /**\n     * Retrieve string at index posizion\n     * @param {string} list concatenation of names\n     * @param {number} index target name index\n     * @returns {string} index-th string\n     * @private\n     */\n    static nameByIndex(list, index) {\n        if (typeof list !== 'string') {\n            throw new Error(`[BelfioreConnector.nameByIndex] Provided list is not a string`);\n        }\n        if (!list.length) {\n            throw new Error(`[BelfioreConnector.nameByIndex] Provided list empty`);\n        }\n        let startIndex = 0,\n            endIndex = list.indexOf('|', startIndex + 1),\n            counter = index;\n\n        while (counter > 0 && endIndex > startIndex) {\n            counter--;\n            startIndex = endIndex + 1;\n            endIndex = list.indexOf('|', startIndex + 1);\n        }\n        \n        if (index < 0 || counter > 0) {\n            throw new Error(`[BelfioreConnector.nameByIndex] Provided index ${index} is out range`);\n        }\n\n        if (!counter && endIndex < 0) {\n            return list.substring(startIndex);\n        }\n\n        return list.substring(startIndex, endIndex);\n    }\n\n    /**\n     * Retrieve string at index posizion\n     * @generator\n     * @param {string} list concatenation of names\n     * @param {string|RegExp} matcher target name index\n     * @yields {number} index\n     * @returns {number} -1 when Done\n     * @private\n     */\n    static* indexByName(list, matcher) {\n        if (typeof list !== 'string') {\n            throw new Error(`[BelfioreConnector.indexByName] Provided list is not a string`);\n        }\n        if (!list.length) {\n            throw new Error(`[BelfioreConnector.indexByName] Provided list empty`);\n        }\n        const regExpMatcher = typeof matcher === 'string' ? new RegExp(matcher, 'i') : matcher;\n        \n        if (!(regExpMatcher instanceof RegExp)) {\n            throw new Error(\"Provided matcher must be of type string or RegExp\");\n        }\n\n        const seekEntryEndIndex = index => list.indexOf('|', index +1) + 1 || list.length;\n        \n        for(let startIndex = 0, entryIndex = 0; startIndex < list.length; entryIndex++) {\n            const endIndex = seekEntryEndIndex(startIndex);\n            const targetName = list.substring(startIndex, endIndex -1);\n            if (regExpMatcher.test(targetName)) {\n                yield entryIndex;\n            }\n            // Moving to next entry to chgeck\n            startIndex = endIndex;\n        }\n        return -1;\n    }\n\n    /**\n     * Retrieve location for the given index in the given subset\n     * @param {string} resourceData concatenation of names\n     * @param {number} index target name index\n     * @returns {Object} location\n     * @private\n     */\n    static locationByIndex(resourceData, index, { activeDate, codeMatcher, province, licenses } = {}) {\n        const belfioreIndex = index * 3;\n        if (resourceData.belfioreCode.length - belfioreIndex < 3) {\n            return null;\n        }\n        const belFioreInt = parseInt(resourceData.belfioreCode.substr(belfioreIndex, 3), '32');\n        const belfioreCode = this.belfioreFromInt(belFioreInt);\n        if (codeMatcher && !codeMatcher.test(belfioreCode)) {\n            return null;\n        }\n        const code = resourceData.provinceOrCountry.substr(index * 2, 2);\n        if (province && province !== code) {\n            return null;\n        }\n\n        const dateIndex = index * 4;\n        const creationDate = this.decodeDate((resourceData.creationDate || '').substr(dateIndex, 4) || '0').startOf('day');\n        const expirationDate = this.decodeDate((resourceData.expirationDate || '').substr(dateIndex, 4) || '2qn13').endOf('day');\n        if (\n            activeDate && \n            (\n                resourceData.creationDate && activeDate.isBefore(creationDate, 'day') ||\n                resourceData.expirationDate &&  activeDate.isAfter(expirationDate, 'day')\n            )\n        ) {\n            return null;\n        }\n        const name = this.nameByIndex(resourceData.name, index);\n        const isCountry = belfioreCode[0] === 'Z';\n\n        const dataSource = licenses[parseInt(parseInt(resourceData.dataSource, 32).toString(2).padStart(resourceData.belfioreCode.length * 2/3, 0).substr(index * 2, 2), 2)];\n\n        return Object.assign({\n            belfioreCode,\n            name,\n            creationDate: creationDate.toDate(),\n            expirationDate: expirationDate.toDate(),\n            dataSource\n        }, isCountry ? {\n            iso3166: code\n        } : {\n            province: code\n        });\n    }\n}\n\nexport const Belfiore = new BelfioreConnector(CITIES_COUNTRIES);\nexport {BelfioreConnector};","const CONSONANT_LIST = 'B-DF-HJ-NP-TV-Z';\nconst VOWEL_LIST = 'AEIOU';\nconst OMOCODE_NUMBER_LIST = '\\\\dLMNP-V';\nconst OMOCODE_NON_ZERO_NUMBER_LIST = '1-9MNP-V';\nconst OMOCODE_ZERO_LIST = '0L';\nconst MONTH_LIST = 'A-EHLMPR-T';\nconst MONTH_30DAYS_LIST = 'DHPS';\nconst MONTH_31DAYS_LIST = 'ACELMRT';\nconst CITY_CODE_LIST = 'A-M';\nconst COUNTRY_CODE_LIST = 'Z';\n\nconst CF_NAME_MATCHER = `[A-Z][${VOWEL_LIST}][${VOWEL_LIST}X]|[${CONSONANT_LIST}]{2}[A-Z]`;\nconst CF_SURNAME_MATCHER = CF_NAME_MATCHER;\nconst CF_FULL_NAME_MATCHER = `(?:${CF_NAME_MATCHER}){2}`;\n\nconst YEAR_MATCHER = `[${OMOCODE_NUMBER_LIST}]{2}`;\nconst LEAP_YEAR_MATCHER = '[02468LNQSU][048LQU]|[13579MPRTV][26NS]';\nconst MONTH_MATCHER = `[${MONTH_LIST}]`;\nconst DAY_2X_MATCHER = '[26NS]';\nconst DAY_3X_MATCHER = '[37PT]';\nconst DAY_29_MATCHER = `[${OMOCODE_ZERO_LIST}4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[1256MNRS][${OMOCODE_NUMBER_LIST}]`;\nconst DAY_30_MATCHER = `[${DAY_3X_MATCHER}][${OMOCODE_ZERO_LIST}]`;\nconst DAY_31_MATCHER = `[${DAY_3X_MATCHER}][${OMOCODE_ZERO_LIST}1M]`;\n\nconst DAY_MATCHER = `(?:${DAY_29_MATCHER}|${DAY_3X_MATCHER}[${OMOCODE_ZERO_LIST}1M])`;\nconst MALE_DAY_MATCHER = `(?:[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[12MN][${OMOCODE_NUMBER_LIST}]|[3P][${OMOCODE_ZERO_LIST}1M])`;\nconst FEMALE_DAY_MATCHER = `(?:[4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[56RS][${OMOCODE_NUMBER_LIST}]|[7T][${OMOCODE_ZERO_LIST}1M])`;\nconst MONTH_DAY_MATCHER = `${MONTH_MATCHER}(?:${DAY_29_MATCHER})|[${MONTH_30DAYS_LIST}]${DAY_30_MATCHER}|[${MONTH_31DAYS_LIST}]${DAY_31_MATCHER}`;\nconst FULL_DATE_MATCHER = `${YEAR_MATCHER}(?:${MONTH_MATCHER}(?:[${OMOCODE_ZERO_LIST}4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[15MR][${OMOCODE_NUMBER_LIST}]|${DAY_2X_MATCHER}[0-8LMNP-U])|[${MONTH_30DAYS_LIST}]${DAY_3X_MATCHER}[${OMOCODE_ZERO_LIST}]|[${MONTH_31DAYS_LIST}]${DAY_3X_MATCHER}[${OMOCODE_ZERO_LIST}1M]|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}]${DAY_2X_MATCHER}[9V])|(?:${LEAP_YEAR_MATCHER})B${DAY_2X_MATCHER}[9V]`;\nconst MALE_FULL_DATE_MATCHER = `${YEAR_MATCHER}(?:${MONTH_MATCHER}(?:[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[1M][${OMOCODE_NUMBER_LIST}]|[2N][0-8LMNP-U])|[${MONTH_30DAYS_LIST}][3P][${OMOCODE_ZERO_LIST}]|[${MONTH_31DAYS_LIST}][3P][${OMOCODE_ZERO_LIST}1M]|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}][2N][9V])|(?:${LEAP_YEAR_MATCHER})B[2N][9V]`;\nconst FEMALE_FULL_DATE_MATCHER = `${YEAR_MATCHER}(?:${MONTH_MATCHER}(?:[4Q][${OMOCODE_NON_ZERO_NUMBER_LIST}]|[5R][${OMOCODE_NUMBER_LIST}]|[6S][0-8LMNP-U])|[${MONTH_30DAYS_LIST}][7T][${OMOCODE_ZERO_LIST}]|[${MONTH_31DAYS_LIST}][7T][${OMOCODE_ZERO_LIST}1M]|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}][6S][9V])|(?:${LEAP_YEAR_MATCHER})B[6S][9V]`;\n\nconst CITY_CODE_MATCHER = `[${CITY_CODE_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]{2}|[${OMOCODE_ZERO_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]|[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]))`;\nconst COUNTRY_CODE_MATCHER = `${COUNTRY_CODE_LIST}[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]{2}`;\nconst BELFIORE_CODE_MATCHER = `(?:[${CITY_CODE_LIST}${COUNTRY_CODE_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]{2})|(?:[${CITY_CODE_LIST}][${OMOCODE_ZERO_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]|[${OMOCODE_ZERO_LIST}][${OMOCODE_NON_ZERO_NUMBER_LIST}]))`;\n\nconst CHECK_DIGIT = '[A-Z]';\n\nconst CODICE_FISCALE = `${CF_FULL_NAME_MATCHER}(?:${FULL_DATE_MATCHER})(?:${BELFIORE_CODE_MATCHER})${CHECK_DIGIT}`;\n\n\nconst PARTIAL_CF_NAME_MATCHER = `[A-Z][${VOWEL_LIST}]?|[${CONSONANT_LIST}]{1,2}`;\nconst PARTIAL_CF_FULL_NAME = `(?:${PARTIAL_CF_NAME_MATCHER})|(?:(?:${CF_NAME_MATCHER})(?:${PARTIAL_CF_NAME_MATCHER})?)`;\nconst PARTIAL_YEAR = `[${OMOCODE_NUMBER_LIST}]`;\nconst PARTIAL_MONTH_DAY = `${MONTH_MATCHER}[${OMOCODE_ZERO_LIST}12456MNQRS]?|[${MONTH_30DAYS_LIST}${MONTH_31DAYS_LIST}]${DAY_3X_MATCHER}`;\nconst PARTIAL_FULL_DATE =`${PARTIAL_YEAR}|(?:${YEAR_MATCHER}(?:${PARTIAL_MONTH_DAY})?)`;\nconst PARTIAL_BELFIORE_CODE_MATCHER = `[${CITY_CODE_LIST}${COUNTRY_CODE_LIST}](?:[${OMOCODE_NON_ZERO_NUMBER_LIST}][${OMOCODE_NUMBER_LIST}]?)?|[${COUNTRY_CODE_LIST}](?:[${OMOCODE_ZERO_LIST}][${OMOCODE_NUMBER_LIST}]?)?`;\n\nconst PARTIAL_CF = `${PARTIAL_CF_FULL_NAME}|(?:${CF_FULL_NAME_MATCHER}(?:(?:${PARTIAL_FULL_DATE})|(?:${FULL_DATE_MATCHER})(?:(?:${PARTIAL_BELFIORE_CODE_MATCHER})|(?:${BELFIORE_CODE_MATCHER})${CHECK_DIGIT}?)?)?)?`;\n\n/**\n * Validator constants\n * @readonly\n * @returns {Object} VALIDATOR\n * \n * @constant {string} VALIDATOR.CONSONANT_LIST List of consonant to be used in a RegExp\n * @constant {string} VALIDATOR.VOWEL_LIST List of vowels to be used in a RegExp\n * @constant {string} VALIDATOR.OMOCODE_NUMBER_LIST List of numbers and their omocode counterparts to be used in a RegExp\n * @constant {string} VALIDATOR.OMOCODE_NON_ZERO_NUMBER_LIST List of numbers but 0 and their omocode counterparts to be used in a RegExp\n * @constant {string} VALIDATOR.OMOCODE_ZERO_LIST List of 0 and its omocode counterpart to be used in a RegExp\n * @constant {string} VALIDATOR.MONTH_LIST\n * @constant {string} VALIDATOR.MONTH_30DAYS_LIST\n * @constant {string} VALIDATOR.MONTH_31DAYS_LIST\n * @constant {string} VALIDATOR.CITY_CODE_LIST\n * @constant {string} VALIDATOR.COUNTRY_CODE_LIST\n * @constant {string} VALIDATOR.CF_NAME_MATCHER\n * @constant {string} VALIDATOR.CF_SURNAME_MATCHER\n * @constant {string} VALIDATOR.CF_FULL_NAME_MATCHER\n * @constant {string} VALIDATOR.YEAR_MATCHER\n * @constant {string} VALIDATOR.LEAP_YEAR_MATCHER\n * @constant {string} VALIDATOR.MONTH_MATCHER\n * @constant {string} VALIDATOR.DAY_29_MATCHER\n * @constant {string} VALIDATOR.DAY_30_MATCHER\n * @constant {string} VALIDATOR.DAY_31_MATCHER\n * @constant {string} VALIDATOR.DAY_MATCHER\n * @constant {string} VALIDATOR.MALE_DAY_MATCHER\n * @constant {string} VALIDATOR.FEMALE_DAY_MATCHER\n * @constant {string} VALIDATOR.MONTH_DAY_MATCHER\n * @constant {string} VALIDATOR.FULL_DATE_MATCHER\n * @constant {string} VALIDATOR.MALE_FULL_DATE_MATCHER\n * @constant {string} VALIDATOR.FEMALE_FULL_DATE_MATCHER\n * @constant {string} VALIDATOR.CITY_CODE_MATCHER\n * @constant {string} VALIDATOR.COUNTRY_CODE_MATCHER\n * @constant {string} VALIDATOR.BELFIORE_CODE_MATCHER\n * @constant {string} VALIDATOR.CHECK_DIGIT\n * @constant {string} VALIDATOR.CODICE_FISCALE\n * @constant {string} VALIDATOR.PARTIAL_CF_NAME_MATCHER\n * @constant {string} VALIDATOR.PARTIAL_CF_FULL_NAME\n * @constant {string} VALIDATOR.PARTIAL_YEAR\n * @constant {string} VALIDATOR.PARTIAL_MONTH_DAY\n * @constant {string} VALIDATOR.PARTIAL_FULL_DATE\n * @constant {string} VALIDATOR.PARTIAL_BELFIORE_CODE_MATCHER\n * @constant {string} VALIDATOR.PARTIAL_CF\n * \n * @namespace VALIDATOR\n */\nexport default Object.freeze({\n    CONSONANT_LIST,\n    VOWEL_LIST,\n    OMOCODE_NUMBER_LIST,\n    OMOCODE_NON_ZERO_NUMBER_LIST,\n    OMOCODE_ZERO_LIST,\n    MONTH_LIST,\n    MONTH_30DAYS_LIST,\n    MONTH_31DAYS_LIST,\n    CITY_CODE_LIST,\n    COUNTRY_CODE_LIST,\n    CF_NAME_MATCHER,\n    CF_SURNAME_MATCHER,\n    CF_FULL_NAME_MATCHER,\n    YEAR_MATCHER,\n    LEAP_YEAR_MATCHER,\n    MONTH_MATCHER,\n    DAY_29_MATCHER,\n    DAY_30_MATCHER,\n    DAY_31_MATCHER,\n    DAY_MATCHER,\n    MALE_DAY_MATCHER,\n    FEMALE_DAY_MATCHER,\n    MONTH_DAY_MATCHER,\n    FULL_DATE_MATCHER,\n    MALE_FULL_DATE_MATCHER,\n    FEMALE_FULL_DATE_MATCHER,\n    CITY_CODE_MATCHER,\n    COUNTRY_CODE_MATCHER,\n    BELFIORE_CODE_MATCHER,\n    CHECK_DIGIT,\n    CODICE_FISCALE,\n    PARTIAL_CF_NAME_MATCHER,\n    PARTIAL_CF_FULL_NAME,\n    PARTIAL_YEAR,\n    PARTIAL_MONTH_DAY,\n    PARTIAL_FULL_DATE,\n    PARTIAL_BELFIORE_CODE_MATCHER,\n    PARTIAL_CF\n});","import VALIDATOR from './validator.const';\n\nconst CONTROL_CODE_IN = {\n    'A': 1,\n    'B': 0,\n    'C': 5,\n    'D': 7,\n    'E': 9,\n    'F': 13,\n    'G': 15,\n    'H': 17,\n    'I': 19,\n    'J': 21,\n    'K': 2,\n    'L': 4,\n    'M': 18,\n    'N': 20,\n    'O': 11,\n    'P': 3,\n    'Q': 6,\n    'R': 8,\n    'S': 12,\n    'T': 14,\n    'U': 16,\n    'V': 10,\n    'W': 22,\n    'X': 25,\n    'Y': 24,\n    'Z': 23\n};\n\n\n/**\n * CodiceFiscal 16th char check digit calculator\n * @class\n * @public\n *//**\n *\n * @namespace CheckDigitizer\n */\nclass CheckDigitizer {\n\n    /**\n     * Partial FiscalCode Evaluator\n     * @param {string} [partialCF=''] Partial Fiscal Code to evaluate\n     * @generator\n     * @yields {number} character value odd/even\n     * @returns {number} 0\n     * @public\n     */\n    static* evaluateChar(partialCF = '') {\n        for(let index in partialCF.split('')){\n            const char = partialCF[index].toUpperCase();\n            const isNumber = (/^\\d/u).test(char);\n            //Odd/Even are shifted/swapped (array starts from 0, 'Agenzia delle Entrate' documentation counts the string from 1)\n            if (index%2) {\n                //Odd positions\n                yield char.charCodeAt(0) - (isNumber ? 48 : 65);\n            } else {\n                //Even positions\n                yield CONTROL_CODE_IN[isNumber ? String.fromCharCode(parseInt(char) + 65) : char];\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Evaluate given partial CF to produce last check digit character\n     * @param {string} codiceFiscale Partial or complete Fiscal Code to evaluate to produce last character\n     * @returns {char|null} 16th CF char\n     * @public\n     */\n    static checkDigit(codiceFiscale) {\n        if (typeof codiceFiscale === 'string' && (new RegExp(VALIDATOR.PARTIAL_CF)).test(codiceFiscale)) {\n            const partialCF = codiceFiscale.substr(0, 15);\n            let partialCfValue = 0;\n            for (let charValue of this.evaluateChar(partialCF)) partialCfValue += charValue;\n            return String.fromCharCode(partialCfValue%26 + 65);\n        }\n        return null;\n    }\n}\n\nexport default CheckDigitizer;","const YEAR = '[12][0-9]{3}';\nconst MONTH = '0[1-9]|1[0-2]';\nconst DAY = '0[1-9]|[12][0-9]|3[01]';\nconst LEAP_MONTH = '02';\nconst DAYS_30_MONTHS = '0[469]|11';\nconst DAYS_31_MONTHS = '0[13578]|1[02]';\nconst MONTH_DAY = `(?:${MONTH})-(?:0[1-9]|[12]\\\\d)|(?:${DAYS_30_MONTHS})-30|(?:${DAYS_31_MONTHS})-3[01]`;\nconst HOURS = '[01]\\\\d|2[0-3]';\nconst MINUTES = '[0-5]\\\\d';\nconst SECONDS = MINUTES;\nconst MILLISECONDS = '\\\\d{3}';\nconst TIMEZONE = `Z|[-+](?:${HOURS})(?::?${MINUTES})?`;\nconst TIME = `(?:${HOURS})(?::${MINUTES}(?::${SECONDS}(\\\\.${MILLISECONDS})?)?(?:${TIMEZONE})?)?`;\nconst ISO8601_SHORT_DATE = `${YEAR}-(?:${MONTH_DAY})(?:T${TIME})?`;\nconst ISO8601_DATE_TIME = `${YEAR}(?:-(?:(?:${MONTH})|(?:${MONTH_DAY})(?:T${TIME})?))?`;\n\n/**\n * Date Validator propertys\n * @namespace DATE_VALIDATOR\n * @property {Object} DATE_VALIDATOR\n * @property {string} DATE_VALIDATOR.YEAR String matcher for ISO8601 4 digits year (limited to 1000-2999)\n * @property {string} DATE_VALIDATOR.MONTH String matcher for ISO8601 2 digits month (01-12)\n * @property {string} DATE_VALIDATOR.DAY String matcher for ISO8601 2 digits day (01-31)\n * @property {string} DATE_VALIDATOR.LEAP_MONTH String matcher for ISO8601 2 digits leap month\n * @property {string} DATE_VALIDATOR.DAYS_30_MONTHS String matcher for ISO8601 2 digits 30 days month\n * @property {string} DATE_VALIDATOR.DAYS_31_MONTHS String matcher for ISO8601 2 digits 31 days month\n * @property {string} DATE_VALIDATOR.MONTH_DAY String matcher for ISO8601 2 digits month + 2 digit day tailored for 28/29, 30 and 31 days months (##-##)\n * @property {string} DATE_VALIDATOR.ISO8601_SHORT_DATE String matcher for ISO8601 date: 4 digits year, 2 digits month and 2 digit day tailored for 28/29, 30 and 31 days months (####-##-##)\n * @property {string} DATE_VALIDATOR.HOURS String matcher for ISO8601 2 digits hours (00-23)\n * @property {string} DATE_VALIDATOR.MINUTES String matcher for ISO8601 2 digits minutes (00-59)\n * @property {string} DATE_VALIDATOR.SECONDS String matcher for ISO8601 2 digits seconds (00-59)\n * @property {string} DATE_VALIDATOR.MILLISECONDS String matcher for ISO8601 3 digits milliseconds (000-999)\n * @property {string} DATE_VALIDATOR.TIMEZONE String matcher for ISO8601 timezone (Z or ## or ##:## or ####)\n * @property {string} DATE_VALIDATOR.TIME String matcher for ISO8601 for time (T## , T##:## , T##:##:## , T##:##:##.###)\n * @property {string} DATE_VALIDATOR.ISO8601_DATE_TIME String matcher for ISO8601 date/time format\n*/\nexport default Object.freeze({\n    YEAR,\n    MONTH,\n    DAY,\n    LEAP_MONTH,\n    DAYS_30_MONTHS,\n    DAYS_31_MONTHS,\n    MONTH_DAY,\n    ISO8601_SHORT_DATE,\n    HOURS,\n    MINUTES,\n    SECONDS,\n    MILLISECONDS,\n    TIMEZONE,\n    TIME,\n    ISO8601_DATE_TIME\n});","const GENDERS = {\n    M: 0,\n    F: 40\n};\n\n/**\n * @namespace Gender\n * @property {number} M 0\n * @property {number} F 40\n * @property {function({number})} parseNumberToGender\n */\nexport default Object.freeze(new Proxy(Object.assign({}, GENDERS), {\n    get(receiver, name) {\n        if (typeof name  === 'string') {\n            const index = parseInt(name);\n            const values = this.toArray.apply(receiver);\n            if (!isNaN(index) && (index >= 0 && index <= 31 || index >= 40 && index <= 71)) {\n                return values[Math.floor(index/40)];\n            }\n            if (typeof this[name] === 'function') {\n                return (...args) => this[name].apply(receiver, args);\n            }\n        }\n        return this[name] || receiver[name];\n    },\n\n    /**\n     * Return an array of Gender constants\n     *\n     * @returns {Array<string>} List of Gender keys\n     * @memberof Gender\n     */\n    toArray(){\n        return Object.keys(this);\n    }\n}));","const OMOCODE = [\n    'L',\n    'M',\n    'N',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V'\n];\n\n/**\n * @namespace Omocode\n * @returns {Proxy}\n * @property {number} L\n * @property {number} M\n * @property {number} N\n * @property {number} P\n * @property {number} Q\n * @property {number} R\n * @property {number} S\n * @property {number} T\n * @property {number} U\n * @property {number} V\n */\nexport default Object.freeze(new Proxy({ OMOCODE }, {\n    get(receiver, name) {\n        if(typeof name  === 'string'){\n            const omocodeChar = name.toUpperCase();\n            if (receiver.OMOCODE.includes(omocodeChar)) {\n                return receiver.OMOCODE.indexOf(omocodeChar);\n            }\n        }\n        return this[name] || receiver.OMOCODE[name] || receiver[name];\n    }\n}));","import {Belfiore} from './belfiore';\nimport BirthMonth from './birthMonth.enum';\nimport CheckDigitizer from './checkDigitizer';\nimport DATE_VALIDATOR from './dateValidator.const';\nimport DiacriticRemover from '@marketto/diacritic-remover';\nimport Gender from './gender.enum';\nimport moment from 'moment';\nimport Omocode from './omocode.enum';\nimport VALIDATOR from './validator.const';\n\n/**\n * @namespace Parser\n */\nclass Parser {\n\n    /**\n     * Default omocode bitmap\n     * @readonly\n     * @returns {number} Omocode bitmap number\n     * @public\n     */\n    static get OMOCODE_BITMAP(){\n        return 0b0111011011000000;\n    }\n\n    /**\n     * Parse surname information\n     * \n     * @param {string} codiceFiscale Partial or complete Omocode/Regular CF to parse\n     * @returns {string|null} Regular CF w/o omocodes chars\n     * @public\n     */\n    static cfDeomocode(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 7) {\n            return codiceFiscale;\n        }\n\n        const checkBitmap = offset => !!(2**offset & this.OMOCODE_BITMAP);\n\n        return codiceFiscale.replace(/[\\dA-Z]/giu, (match, offset) => (/^[A-Z]$/giu).test(match) && checkBitmap(offset) ? Omocode[match] : match);\n    }\n\n    /**\n     * Parse surname information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {string|null} Partial/possible surname\n     * @public\n     */\n    static cfToSurname(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 3 || !(/^[A-Z]{3}/iu).test(codiceFiscale)) {\n            return null;\n        }\n\n        const surnameCf = codiceFiscale.substr(0,3);\n\n        const [cons = ''] = surnameCf.match(new RegExp(`^[${VALIDATOR.CONSONANT_LIST}]{1,3}`, 'ig')) || [];\n        const [vow = ''] = surnameCf.match(new RegExp(`[${VALIDATOR.VOWEL_LIST}]{1,3}`, 'ig')) || [];\n\n        const matchingLength = cons.length + vow.length;\n\n        if (matchingLength < 2 || matchingLength < 3 && surnameCf[2].toUpperCase() !== 'X') {\n            return null;\n        }\n\n        switch(cons.length) {\n        case 3:\n            return (cons + vow).split('').join('*') + '*';\n        case 2:\n            return `${cons[0]}${vow[0]}*${cons[1]}*`;\n        case 1:\n            return `${cons[0]}${vow}*`;\n        default:\n            return `${vow}${vow.length === 3 ? '*': ''}`;\n        }\n    }\n\n    /**\n     * Parse name information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {string|null} Partial/possible name\n     * @public\n     */\n    static cfToName(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 3 || !(/^[A-Z]{6}/iu).test(codiceFiscale)) {\n            return null;\n        }\n        return this.cfToSurname(codiceFiscale.substr(3, 3));\n    }\n\n    /**\n     * Parse gender information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {'M'|'F'|null} Male or female\n     * @public\n     */\n    static cfToGender(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 11) {\n            return null;\n        }\n        const birthDay = parseInt(codiceFiscale.substr(9,2));\n        if (birthDay === 0 || birthDay === 40) {\n            return null;\n        }\n        return Gender[birthDay];\n    }\n\n    /**\n     * Parse birth year information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {number|null} Birth Year (4 digits)\n     * @public\n     */\n    static cfToBirthYear(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 8) {\n            return null;\n        }\n        const birthYear = parseInt(codiceFiscale.substr(6,2));\n\n        if (isNaN(birthYear)) {\n            return null;\n        }\n\n        const current2DigitsYear = parseInt(moment().format('YY'));\n\n        const century = (birthYear > current2DigitsYear) * 100;\n        return moment().subtract(current2DigitsYear - birthYear + century, 'years').year();\n    }\n\n    /**\n     * Parse birth month information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {number|null} Birth Month (0...11 - Date notation)\n     * @public\n     */\n    static cfToBirthMonth(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 9) {\n            return null;\n        }\n\n        const birthMonth = BirthMonth[codiceFiscale.substr(8,1)];\n        if (!birthMonth && birthMonth !== 0) {\n            return null;\n        }\n        return birthMonth;\n    }\n\n    /**\n     * Parse birth day information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {number|null} Birth day (1..31)\n     * @public\n     */\n    static cfToBirthDay(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 11) {\n            return null;\n        }\n        let birthDay = parseInt(codiceFiscale.substr(9,2));\n\n        if (isNaN(birthDay)) {\n            return null;\n        }\n\n        birthDay -= birthDay >= 40 ? 40 : 0;\n\n        if (birthDay < 1 || birthDay > 31) {\n            return null;\n        }\n        return birthDay;\n    }\n\n    /**\n     * Parse birth date information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {Date|null} Birth Date\n     * @public\n     */\n    static cfToBirthDate(codiceFiscale) {\n        const birthDay = this.cfToBirthDay(codiceFiscale);\n        if (!birthDay) {\n            return null;\n        }\n\n        const birthMonth = this.cfToBirthMonth(codiceFiscale);\n        if (!birthMonth && birthMonth !== 0) {\n            return null;\n        }\n\n        const birthYear = this.cfToBirthYear(codiceFiscale);\n        if (!birthYear) {\n            return null;\n        }\n\n        const dt = moment(Date.UTC(birthYear, birthMonth, birthDay));\n        if (!dt.isValid()) {\n            return null;\n        }\n        return dt.toDate();\n    }\n\n    /**\n     * Parse birth place information\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {Object} {name, belfioreCode} Birth place\n     * @public\n     */\n    static cfToBirthPlace(codiceFiscale) {\n        if (typeof codiceFiscale !== 'string' || codiceFiscale.length < 15) {\n            return null;\n        }\n\n\n        const birthPlace = Belfiore[codiceFiscale.substr(11,4).toUpperCase()];\n        if (!birthPlace) {\n            return null;\n        }\n\n        const {creationDate, expirationDate} = birthPlace;\n        if (creationDate || expirationDate) {\n            const birthDate = this.cfToBirthDate(codiceFiscale);\n            if (!birthDate) {\n                return null;\n            }\n            let validityCheck = true;\n            if (creationDate) {\n                validityCheck = moment(birthDate).isSameOrAfter(moment(creationDate));\n            }\n            if(validityCheck && expirationDate) {\n                validityCheck = moment(birthDate).isSameOrBefore(moment(expirationDate));\n            }\n            if (!validityCheck) {\n                return null;\n            }\n        }\n        return birthPlace;\n    }\n\n    /**\n     * @param {string} fiscalCode 16 character Codice Fiscale to decode\n     * @returns {Object} {surname, name, year, month, day, gender, place} Decoded CF Info\n     */\n    static cfDecode(fiscalCode) {\n        const year = this.cfToBirthYear(fiscalCode),\n            month = this.cfToBirthMonth(fiscalCode),\n            day = this.cfToBirthDay(fiscalCode);\n        return {\n            surname: this.cfToSurname(fiscalCode),\n            name: this.cfToName(fiscalCode),\n\n            year,\n            month,\n            day,\n            date: new Date(Date.UTC(year, month, day)),\n\n            gender: this.cfToGender(fiscalCode),\n            place: (this.cfToBirthPlace(fiscalCode) || {}).name\n        };\n    }\n\n    /**\n     * Parse surname to cf part\n     * \n     * @param {string} surname Partial or complete CF to parse\n     * @returns {string|null} partial cf\n     * @public\n     */\n    static surnameToCf(surname) {\n        if ((surname || '').trim().length < 2) {\n            return null;\n        }\n        const diacriticRemover = new DiacriticRemover();\n        const noDiacriticsSurname = diacriticRemover.replace(surname).trim();\n        if (!(/^[A-Z ']+$/iu).test(noDiacriticsSurname)) {\n            return null;\n        }\n        const consonants = (noDiacriticsSurname.match(new RegExp(`[${VALIDATOR.CONSONANT_LIST}]+`, 'ig')) || []).join('');\n        const vowels = (noDiacriticsSurname.match(new RegExp(`[${VALIDATOR.VOWEL_LIST}]+`, 'ig')) || []).join('');\n\n        const partialCf = (consonants + vowels).padEnd(3, 'X').substr(0, 3);\n\n        if (partialCf.length < 3) {\n            return null;\n        }\n        return partialCf.toUpperCase();\n    }\n\n    /**\n     * Parse name to cf part\n     * \n     * @param {string} name Partial or complete CF to parse\n     * @returns {string|null} partial cf\n     * @public\n     */\n    static nameToCf(name) {\n        if ((name || '').trim().length < 2) {\n            return null;\n        }\n        \n        const diacriticRemover = new DiacriticRemover();\n        const noDiacriticsName = diacriticRemover.replace(name);\n        const consonants = (noDiacriticsName.match(new RegExp(`[${VALIDATOR.CONSONANT_LIST}]+`, 'ig')) || []).join('');\n\n        if (consonants.length >= 4) {\n            return (consonants[0] + consonants.substr(2, 2)).toUpperCase();\n        }\n        return this.surnameToCf(name);\n    }\n\n    /**\n     * Parse year to cf part\n     * \n     * @param {string|number} year Birth year 2 or 4 digit string, number above 19XX or below 100\n     * @returns {string|null} partial cf\n     * @public\n     */\n    static yearToCf(year) {\n        let parsedYear = year;\n        if (typeof year === 'string') {\n            parsedYear = parseInt(year);\n        }\n        if (!(typeof parsedYear === 'number' && !isNaN(parsedYear) &&(parsedYear >= 1900 || parsedYear < 100))) {\n            return null;\n        }\n        return `0${parsedYear}`.substr(-2);\n    }\n\n    /**\n     * Parse month information\n     * \n     * @param {number} month Month number 0..11\n     * @returns {string|null} Birth Month CF code\n     * @public\n     */\n    static monthToCf(month) {\n        if (!(typeof month === 'number' && !isNaN(month))) {\n            return null;\n        }\n\n        return BirthMonth[month] || null;\n    }\n\n    /**\n     * Parse day information\n     * \n     * @param {number} day Day number 1..31\n     * @param {Gender|string} gender Gender enum value\n     * @returns {string|null} Birth Day CF code\n     * @public\n     */\n    static dayGenderToCf(day, gender) {\n        if (!(typeof day === 'number' && !isNaN(day) && (day > 0 && day < 32))) {\n            return null;\n        }\n        const genderValue = Gender[gender];\n        if (typeof genderValue !== 'number') {\n            return null;\n        }\n        return `0${day + genderValue}`.substr(-2);\n    }\n\n    /**\n     * Parse Year, Month, Day to Dated\n     * \n     * @param {number} year 4 digits Year\n     * @param {number} [month = 0] 1 or 2 digits Month 0..11\n     * @param {number} [day = 1] 1,2 digits Day 1..31\n     * @returns {Date|null} Date or null if provided year/month/day are not valid\n     */\n    static yearMonthDayToDate(year, month = 0, day = 1) {\n        if ([year, month, day].some(param => typeof param !== 'number') || year < 1861) {\n            return null;\n        }\n        const date = moment(Date.UTC(year, month, day));\n        if (!date.isValid() || date.year() !== year || date.month() !== month || date.date() !== day) {\n            return null;\n        }\n        return date.toDate();\n    }\n\n    /**\n     * Parse a Dated and Gender information to create Date/Gender CF part\n     * \n     * @param {Date|Moment|string|Array<number>} date Date or Moment instance, ISO8601 date string or array of numbers [year, month, day]\n     * @returns {Date|null} Parsed Date or null if not valid\n     * @public\n     */\n    static parseDate(date) {\n        if (!(\n            date instanceof Date ||\n            date instanceof moment ||\n            typeof date === 'string' && (new RegExp(DATE_VALIDATOR.ISO8601_SHORT_DATE)).test(date) ||\n            Array.isArray(date) && !date.some(value => typeof value !== 'number')\n        )) {\n            return null;\n        }\n\n        const parsedDate = moment(date);\n        if (!parsedDate.isValid()){\n            return null;\n        }\n        return parsedDate.toDate();\n    }\n\n    /**\n     * Parse a Dated and Gender information to create Date/Gender CF part\n     * \n     * @param {Date|Moment|string|Array<number>} date Date or Moment instance, ISO8601 date string or array of numbers [year, month, day]\n     * @param {Gender|string} gender Gender enum value\n     * @returns {string|null} Birth date and Gender CF code\n     * @public\n     */\n    static dateGenderToCf(date, gender) {\n        if (!Gender.hasOwnProperty(gender)) {\n            return null;\n        }\n        const parsedDate = this.parseDate(date);\n        if (!parsedDate) {\n            return null;\n        }\n        \n        const cfYear = this.yearToCf(parsedDate.getFullYear());\n        const cfMonth = this.monthToCf(parsedDate.getMonth());\n        const cfDayGender = this.dayGenderToCf(parsedDate.getDate(), gender);\n\n        return `${cfYear}${cfMonth}${cfDayGender}`;\n    }\n\n    /**\n     * Parse a Dated and Gender information to create Date/Gender CF part\n     * \n     * @param {Date|Moment|string|Array<number>} date Date or Moment instance, ISO8601 date string or array of numbers [year, month, day]\n     * @param {string} name City or Country name\n     * @param {string} [province] Province code for cities\n     * @returns {string|null} Matching place belfiore code, if only once is matching criteria\n     * @public\n     *//**\n     * Parse place name and province to Belfiore code\n     * @param {string} name City or Country name\n     * @param {string} [province] Province code for cities\n     * @returns {string|null} Matching place belfiore code, if only once is matching criteria\n     * @public\n     */\n    static placeToCf(...args) {\n        let targetDate = this.parseDate(args[0]);\n\n        let [name, province] = args.filter(input => typeof input === 'string');\n        if (!province) {\n            return (Belfiore.active(targetDate).findByName(name) || {}).belfioreCode;\n        }\n        const results = Belfiore.searchByName(name).toArray().filter(place => province.trim().toUpperCase() === place.province);\n        if (results.length === 1) {\n            return results[0].belfioreCode;\n        }\n        return null;\n    }\n\n    /**\n     * Generates full CF\n     * \n     * @param {Object} input Input Object\n     * @param {string} input.surname Surname\n     * @param {string} input.name Name\n     * @param {number} [input.year] Birth Year\n     * @param {number} [input.month] Birth Month\n     * @param {number} [input.day] Birth Day\n     * @param {Date|Moment} [input.date] Birth Date\n     * @param {Gender|string} input.gender Gender M|F\n     * @param {string} input.place Place name\n     * @returns {string|null} Complete CF\n     */\n    static encodeCf({\n        surname,\n        name,\n\n        year,\n        month,\n        day,\n        date,\n\n        gender,\n        place\n    }) {\n        const dtParams = this.parseDate(date) || this.yearMonthDayToDate(year, month, day);\n        const generator = [\n            () => this.surnameToCf(surname),\n            () => this.nameToCf(name),\n            () => this.dateGenderToCf(dtParams, gender),\n            () => this.placeToCf(dtParams, place),\n            () => CheckDigitizer.checkDigit(cf)\n        ];\n        let cf = '';\n        for (let i=0; i<generator.length; i++) {\n            const cfValue = generator[i]();\n            if (!cfValue) {\n                return null;\n            }\n            cf += cfValue;\n        }\n\n        return cf;\n    }\n}\n\nexport default Parser;","const ERRORS = Object.freeze({\n    INVALID_SURNAME: 'Provided surname is not valid, only letters, diacritics and apostrophe allowed',\n    INVALID_NAME: 'Provided name is not valid, only letters, diacritics and apostrophe allowed',\n    INVALID_DAY: 'Provided day is not valid',\n    INVALID_GENDER: 'Provided gender is not valid',\n    INVALID_DAY_OR_GENDER: 'Provided day and/or gender are not valid',\n    INVALID_YEAR: 'Provided year is not valid, only 2 or 4 digit numbers are allowed',\n    INVALID_DATE: 'Provided date is not valid',\n});\n\nclass Errors {\n    /**\n     * \n     * @param {string} className \n     * @param {string} methodName \n     */\n    constructor(className, methodName) {\n        Object.assign(\n            this,\n            Object.entries(ERRORS)\n                .map(([key, name]) => [key, new Error(`[${className}.${methodName}] ${name}`)])\n                .reduce((accumulator, [key, err]) => Object.assign(accumulator, { [key]: err }), {})\n        );\n    }\n}\n\nexport default Errors;","import CheckDigitizer from './checkDigitizer';\nimport DATE_VALIDATOR from './dateValidator.const';\nimport DiacriticRemover from '@marketto/diacritic-remover';\nimport Gender from './gender.enum';\nimport moment from 'moment';\nimport Omocode from './omocode.enum';\nimport Parser from './parser';\nimport VALIDATOR from './validator.const';\nimport Error from './error';\n/**\n * @namespace Validator\n */\nclass Validator {\n\n    /**\n     * Validation regexp for the given surname or generic\n     * @param {string} surname Optional surname to generate validation regexp\n     * @returns {RegExp} CF Surname matcher\n     * @public\n     */\n    static cfSurname(surname) {\n        const error =  new Error('Validator', 'cfSurname');\n        let matcher = VALIDATOR.CF_NAME_MATCHER;\n        if (surname) {\n            if (!this.surname().test(surname)) {\n                throw error.INVALID_SURNAME;\n            }\n            matcher = Parser.surnameToCf(surname) || matcher;\n        }\n        return new RegExp(`^(?:${matcher})$`, 'iu');\n    }\n\n    /**\n     * Validation regexp for the given name or generic\n     * @param {string} name Optional name to generate validation regexp\n     * @returns {RegExp} CF name matcher\n     * @public\n     */\n    static cfName(name) {\n        const error =  new Error('Validator', 'cfName');\n        let matcher = VALIDATOR.CF_NAME_MATCHER;\n        if (name) {\n            if (!this.surname().test(name)) {\n                throw error.INVALID_NAME;\n            }\n            matcher = Parser.nameToCf(name) || matcher;\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * Validation regexp for the given year or generic\n     * @param {number} year Optional year to generate validation regexp\n     * @returns {RegExp} CF year matcher\n     * @public\n     */\n    static cfYear(year) {\n        const error =  new Error(this.constructor.name, 'cfYear');\n        let matcher = VALIDATOR.YEAR_MATCHER;\n        if (year) {\n            const parsedYear = Parser.yearToCf(year);\n            if (parsedYear) {\n                matcher = parsedYear.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n            } else {\n                throw error.INVALID_YEAR;\n            }\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * Validation regexp for the given month or generic\n     * @param {number} month Optional month to generate validation regexp\n     * @returns {RegExp} CF month matcher\n     * @public\n     */\n    static cfMonth(month) {\n        let matcher = VALIDATOR.MONTH_MATCHER;\n        if (month) {\n            matcher = Parser.monthToCf(month) || matcher;\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * Validation regexp for the given year or generic\n     * @param {number} day Optional day to generate validation regexp\n     * @returns {RegExp} CF day matcher\n     * @public\n     */\n    static cfDay(day) {\n        const error =  new Error('Validator', 'cfDayGender');\n        let matcher = VALIDATOR.DAY_MATCHER;\n        if (day) {\n            const parsedDayM = Parser.dayGenderToCf(day, 'M');\n            if (parsedDayM) {\n                const matcherM = parsedDayM.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n                const matcherF = Parser.dayGenderToCf(day, 'F').replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n                matcher = `(?:${matcherM})|(?:${matcherF})`;\n            } else {\n                throw error.INVALID_DAY;\n            }\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * Validation regexp for the given year or generic\n     * @param {number|null} [day] Optional day to generate validation regexp\n     * @param {'M'|'F'} [gender] Gender @see Gender\n     * @returns {RegExp} CF day and gender matcher\n     * @public\n     */\n    static cfDayGender(day, gender) {\n        const error =  new Error('Validator', 'cfDayGender');\n        if (!gender) {\n            return this.cfDay(day);\n        }\n        let matcher;\n        if (day) {\n            const parsedDayGender = Parser.dayGenderToCf(day, gender);\n            if (parsedDayGender) {\n                matcher = parsedDayGender.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n            } else {\n                throw error.INVALID_DAY_OR_GENDER;\n            }\n        } else {\n            switch (gender) {\n            case 'M':\n                matcher = VALIDATOR.MALE_DAY_MATCHER;\n                break;\n            case 'F':\n                matcher = VALIDATOR.FEMALE_DAY_MATCHER;\n                break;\n            default:\n                throw error.INVALID_GENDER;\n            }\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * Validation regexp for the given year or generic\n     * @param {Date|Moment|Array<number>} date Optional date to generate validation regexp\n     * @param {'M'|'F'} [gender] @see Gender\n     * @returns {RegExp} CF date and gender matcher\n     * @public\n     */\n    static cfDateGender(date, gender) {\n        const error =  new Error('Validator', 'cfDateGender');\n        if (date && !Parser.parseDate(date)) {\n            throw error.INVALID_DATE;\n        }\n        if (gender && !Gender.toArray().includes(gender)) {\n            throw error.INVALID_GENDER;\n        }\n        let matcher = VALIDATOR.FULL_DATE_MATCHER;\n        if (date) {\n            const omocodeReplacer = parsedDateGender => parsedDateGender.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n            matcher = gender ?\n                omocodeReplacer(Parser.dateGenderToCf(date, gender)) :\n                `(?:${omocodeReplacer(Parser.dateGenderToCf(date, 'M'))}|${omocodeReplacer(Parser.dateGenderToCf(date, 'm'))})`;\n        } else {\n            switch (gender) {\n            case 'M':\n                matcher = VALIDATOR.MALE_FULL_DATE_MATCHER;\n                break;\n            case 'F':\n                matcher = VALIDATOR.FEMALE_FULL_DATE_MATCHER;\n                break;\n            }\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * @param {string} placeName Optional place name to generate validation regexp\n     * @returns {RegExp} CF place matcher\n     * @public\n     *//**\n     * @param {Date|Moment|Array<number>} [date] Optional date to generate validation regexp\n     * @param {string} placeName Optional place name to generate validation regexp\n     * @returns {RegExp} CF place matcher\n     * @public\n     */\n    static cfPlace(...args) {\n        let matcher = VALIDATOR.BELFIORE_CODE_MATCHER;\n        if (args.filter(param => !!param).length > moment(args[0]).isValid()) {\n            const parsedPlace = Parser.placeToCf(...args);\n            if (parsedPlace) {\n                matcher = parsedPlace.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n            } else {\n                matcher = '';\n            }\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n    /**\n     * Generates full CF validator based on given optional input or generic\n     * \n     * @param {Object} input Input Object\n     * @param {string} input.surname Surname\n     * @param {string} input.name Name\n     * @param {number} [input.year] Birth Year\n     * @param {number} [input.month] Birth Month\n     * @param {number} [input.day] Birth Day\n     * @param {Date|Moment} [input.date] Birth Date\n     * @param {Gender|string} input.gender Gender M|F\n     * @param {string} input.place Place name\n     * @returns {RegExp} CodiceFiscale matcher\n     */\n    static codiceFiscale(input) {\n        let matcher = VALIDATOR.CODICE_FISCALE;\n        if (input) {\n            const parsedCf = Parser.encodeCf(input);\n\n            if (parsedCf) {\n                matcher = parsedCf.replace(/\\d/gu, n => `[${n}${Omocode[n]}]`);\n            } else {\n                const { surname, name, year, month, day, date, gender, place } = input;\n                if (surname || name || year || month || day || date || gender || place) {\n                    const dtParams = Parser.parseDate(date) || Parser.yearMonthDayToDate(year, month, day);\n                    const generator = [\n                        () => this.cfSurname(surname),\n                        () => this.cfName(name),\n                        () => this.cfDateGender(dtParams, gender),\n                        () => this.cfPlace(dtParams, place)\n                    ];\n\n                    matcher = '';\n                    for (let i=0; i<generator.length; i++) {\n                        const cfPartValidator = generator[i]();\n                        const cfValue = cfPartValidator.toString().match(/\\^(.+)\\$/)[1];\n                        matcher += `(?:${cfValue})`;\n                    }\n                    // Final addition of CheckDigit\n                    matcher += VALIDATOR.CHECK_DIGIT;\n                }\n            }\n        }\n        return new RegExp(`^${matcher}$`, 'iu');\n    }\n\n\n    /**\n     * Returns surname validator based on given cf or generic\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {RegExp} Generic or specific regular expression\n     * @public\n     */\n    static surname(codiceFiscale) {\n        const diacriticRemover = new DiacriticRemover();\n        const LETTER_SET = `[A-Z${diacriticRemover.matcherBy(/^[A-Z]$/ui)}]`;\n        const SEPARATOR_SET = '[\\' ]';\n        const ANY_LETTER = `(?:${LETTER_SET}+${SEPARATOR_SET}?)`;\n        let matcher = `${ANY_LETTER}+`;\n        if (typeof codiceFiscale === 'string' && (/^[A-Z]{1,3}/iu).test(codiceFiscale)) {\n            const surnameCf = codiceFiscale.substr(0,3);\n            \n            const diacriticizer = matchingChars => (matchingChars || '').split('').map(char => `[${diacriticRemover.insensitiveMatcher[char]}]`);\n\n            const matchFromCf = (cf, charMatcher) => diacriticizer((cf.match(new RegExp(charMatcher, 'ig')) || [])[0]);\n\n            const cons = matchFromCf(surnameCf, `^[${VALIDATOR.CONSONANT_LIST}]{1,3}`);\n            const vow = matchFromCf(surnameCf, `[${VALIDATOR.VOWEL_LIST}]{1,3}`);\n            \n            const diacriticsVowelList = VALIDATOR.VOWEL_LIST + diacriticRemover.matcherBy(new RegExp(`^[${VALIDATOR.VOWEL_LIST}]$`, 'ui'));\n            const diacriticsVowelMatcher = `[${diacriticsVowelList}]`;\n            const midDiacriticVowelMatcher = `(?:${diacriticsVowelMatcher}${SEPARATOR_SET}?)*`;\n            const endingDiacritcVowelMatcher = `(?:${SEPARATOR_SET}?${midDiacriticVowelMatcher}${diacriticsVowelMatcher})?`;\n            switch(cons.length) {\n            case 3: {\n                const divider = midDiacriticVowelMatcher;\n                matcher = divider + cons.join(`${SEPARATOR_SET}?${divider}`) + `(?:${SEPARATOR_SET}?${LETTER_SET}*${LETTER_SET})?`;\n                break;\n            }\n            case 2: {\n                const possibilities = [\n                    `${vow[0]}${SEPARATOR_SET}?${cons[0]}${midDiacriticVowelMatcher}${cons[1]}`,\n                    `${cons[0]}${SEPARATOR_SET}?` + vow.join(`${SEPARATOR_SET}?`) + `${SEPARATOR_SET}?${midDiacriticVowelMatcher}${cons[1]}`,\n                    cons.join(`${SEPARATOR_SET}?`) + `${SEPARATOR_SET}?${vow[0]}`\n                ];\n                matcher = `(?:${possibilities.join('|')})${endingDiacritcVowelMatcher}`;\n                break;\n            }\n            case 1: {\n                const possibilities = [\n                    vow.slice(0,2).join(`${SEPARATOR_SET}?`) + midDiacriticVowelMatcher + cons.join(`${SEPARATOR_SET}?`),\n                    `${vow[0]}${SEPARATOR_SET}?` + cons.join(`${SEPARATOR_SET}?`) + vow[1],\n                    [cons[0], ...vow.slice(0,2)].join(`${SEPARATOR_SET}?`)\n                ];\n                matcher = `(?:${possibilities.join('|')})${endingDiacritcVowelMatcher}`;\n                break;\n            }\n            default:\n                matcher = `${vow.join(`${SEPARATOR_SET}?`)}${endingDiacritcVowelMatcher}`;\n            }\n        }\n\n        return new RegExp(`^ *(${matcher}) *$`, 'iu');\n    }\n\n    /**\n     * Returns name validator based on given cf or generic\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {RegExp} Generic or specific regular expression\n     * @public\n     */\n    static name(codiceFiscale) {\n        if (typeof codiceFiscale === 'string' && (new RegExp(`^[A-Z]{3}[${VALIDATOR.CONSONANT_LIST}]{3}`, 'iu')).test(codiceFiscale)) {\n            const diacriticRemover = new DiacriticRemover();\n            const ANY_LETTER = `[A-Z${diacriticRemover.matcherBy(/^[A-Z]$/ui)}]`;\n\n            const nameCf = codiceFiscale.substr(3,3);\n\n            const cons = ((nameCf.match(new RegExp(`^[${VALIDATOR.CONSONANT_LIST}]{1,3}`, 'ig')) || [])[0] || '')\n                .split('').map(char => `[${diacriticRemover.insensitiveMatcher[char]}]`);\n\n            const diacriticizer = chars => chars + diacriticRemover.matcherBy(new RegExp(`^[${chars}]$`, 'ui'));\n\n            const diacriticsVowelList = diacriticizer(VALIDATOR.VOWEL_LIST);\n            const diacriticsConsonantList = diacriticizer(VALIDATOR.CONSONANT_LIST);\n\n            const matcher = `[${diacriticsVowelList}]*${cons[0]}[${diacriticsVowelList}]*(?:[${diacriticsConsonantList}][${diacriticsVowelList}]*)?`\n                + cons.slice(1,3).join(`[${diacriticsVowelList}]*`) + `${ANY_LETTER}*`;\n            \n            return new RegExp(`^${matcher}$`, 'iu');\n        }\n        return this.surname((codiceFiscale || '').substr(3,3));\n    }\n\n    /**\n     * Returns iso8601 date validator based on given cf or generic\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {RegExp} Generic or specific regular expression\n     * @public\n     */\n    static date(codiceFiscale){\n        let matcher = DATE_VALIDATOR.ISO8601_DATE_TIME;\n        if (codiceFiscale) {\n            const parsedDate = Parser.cfToBirthDate(codiceFiscale);\n            if (parsedDate) {\n                const dateIso8601 = parsedDate.toJSON();\n                if (moment().diff(moment(parsedDate), 'y') < 50) {\n                    const century = parseInt(dateIso8601.substr(0,2));\n                    const centuries = [\n                        century -1,\n                        century\n                    ].map(year => year.toString().padStart(2, 0));\n                    matcher = `(?:${centuries.join('|')})` + dateIso8601.substr(2,8);\n                } else {\n                    matcher = dateIso8601.substr(0,10);\n                }\n            }\n        }\n        return new RegExp(`^${matcher}(?:T${DATE_VALIDATOR.TIME}(?:${DATE_VALIDATOR.TIMEZONE})?)?$`, 'iu');\n    }\n\n    /**\n     * Returns gender validator based on given cf or generic\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {RegExp} Generic or specific regular expression\n     * @public\n     */\n    static gender(codiceFiscale) {\n        const parsedGender = Parser.cfToGender(codiceFiscale);\n        const matcher = parsedGender || `[${Gender.toArray().join('')}]`;\n        return new RegExp(`^${matcher}$`, 'u');\n    }\n\n    \n\n    /**\n     * Returns place validator based on given cf or generic\n     * \n     * @param {string} codiceFiscale Partial or complete CF to parse\n     * @returns {RegExp} Generic or specific regular expression\n     * @public\n     */\n    static place(codiceFiscale) {\n        let matcher = '.+';\n        const parsedPlace = Parser.cfToBirthPlace(codiceFiscale);\n\n        if (parsedPlace) {\n            const diacriticRemover = new DiacriticRemover();\n            const nameMatcher = parsedPlace.name.replace(/./gu, c => diacriticRemover[c]===c ? c : `[${c}${diacriticRemover[c]}]`);\n            matcher = `(?:(?:${nameMatcher})|${parsedPlace.belfioreCode})`;\n        }\n\n        return new RegExp(`^${matcher}$`, 'ui');\n    }\n\n    /**\n     * Check the given cf validity by form, birth date/place and digit code\n     * \n     * @param {string} codiceFiscale Complete CF to parse\n     * @returns {boolean} Generic or specific regular expression\n     * @public\n     */\n    static isValid(codiceFiscale) {\n        const matcher = new RegExp(`^(?:${VALIDATOR.CODICE_FISCALE})$`, 'ui');\n        if (\n            // Checking form validity\n            !matcher.test(codiceFiscale) ||\n            //Checking 16th char check digit validity\n            codiceFiscale.substr(15, 1).toUpperCase() !== CheckDigitizer.checkDigit(codiceFiscale) ||\n            //Checking Birth date/place validity\n            !Parser.cfToBirthPlace(codiceFiscale)\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\nexport default Validator;","import BirthMonth from './birthMonth.enum';\nimport { Belfiore, BelfioreConnector } from './belfiore';\nimport CheckDigitizer from './checkDigitizer';\nimport DATE_VALIDATOR from './dateValidator.const';\nimport Gender from './gender.enum';\nimport Omocode from './omocode.enum';\nimport Parser from './parser';\nimport Validator from './validator';\nimport VALIDATOR from './validator.const';\n\n/**\n * @module CodiceFiscaleUtils\n */\nexport {\n    /**\n     * {@link BelfioreConnector}\n     */\n    Belfiore,\n    /**\n     * {@link BelfioreConnector}\n     */\n    BelfioreConnector,\n    /**\n     * {@link BirthMonth}\n     */\n    BirthMonth,\n    /**\n     * {@link CheckDigitizer}\n     */\n    CheckDigitizer,\n    /**\n     * {@link DATE_VALIDATOR}\n     */\n    DATE_VALIDATOR,\n    /**\n     * {@link Gender}\n     */\n    Gender,\n    /**\n     * {@link Omocode}\n     */\n    Omocode,\n    /**\n     * {@link Parser}\n     */\n    Parser,\n    /**\n     * {@link VALIDATOR}\n     */\n    VALIDATOR,\n    /**\n     * {@link Validator}\n     */\n    Validator\n};"],"sourceRoot":""}